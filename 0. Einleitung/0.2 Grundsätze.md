# 0.2 Grundsätze
In diesem Kapitel werden wir uns mit den Grundsätzen des Standards befassen. Diese Grundsätze gelten für alle Komponenten in einem standardkonformen System, unabhängig davon, ob es sich bei diesen Komponenten um Broker, Dienste oder Expositionen handelt.

## 0.2.0 Der Mensch im Mittelpunkt
Der Grundgedanke dieses Prinzips besteht darin, standardkonforme Systeme mit Blick auf die Menschen zu entwickeln, und zwar nicht nur auf die Menschen, die das System nutzen werden, sondern auch auf die Menschen, die es pflegen und weiterentwickeln werden.

Ein System muss der Einfachheit den Vorzug vor der Komplexität geben, um dem Grundsatz Mensch im Mittelpunkt zu folgen. Einfachheit führt zu Umschreibbarkeit. Sie führt auch dazu, monolithische Systeme zu entwerfen, die mit einer modularen Denkweise aufgebaut sind, um eine echte Fraktalität im Gesamtmuster des Systems zu ermöglichen.

Mit der Norm werden auch die Grundsätze der Messung fortgeschrittener technischer Konzepte am Verständnis von Mainstream-Ingenieuren durchgesetzt. Die neuen Ingenieure in der Branche sind die Führungskräfte von morgen. Wenn sie sich nicht in ein System einarbeiten, werden sie irgendwann aufgeben und es wiederholt umschreiben.

### 0.2.0.0 Einfachheit
Code, der nach dem Standard geschrieben wurde, muss einfach sein. Es gibt Maßnahmen, um diese Einfachheit zu gewährleisten; diese Maßnahmen sind wie folgt:

#### 0.2.0.0.0 Übermäßige Vererbung
Jede nach dem Standard geschriebene Software darf nicht mehr als eine Vererbungsebene haben. Mehr als eine Vererbungsebene wird als exzessiv betrachtet und ist verboten, außer in Fällen von Versionierung für die vertikale Skalierung von Abläufen. Übermäßige Vererbung hat sich im Laufe der Jahre als Quelle von Verwirrung und Schwierigkeiten in Bezug auf Lesbarkeit und Wartbarkeit erwiesen.

#### 0.2.0.0.1 Verflechtung

##### 0.2.0.0.1.0 Horizontale Verflechtung
Eine weitere verbotene Praxis in standardkonformen Systemen ist der Aufbau "gemeinsamer" Komponenten in jedem System mit dem Versprechen, den Entwicklungsprozess zu vereinfachen. Diese Praxis manifestiert sich in Komponenten mit Namen wie `Utils`, `Commons` oder `Helpers`. Diese Bezeichnungen und die damit verbundenen falschen Vereinfachungsversprechen sind nicht zulässig. Jedes System, das nach dem Standard aufgebaut ist, sollte aus Brokern, Services oder Expositionen bestehen, nicht mehr und nicht weniger.

Ein weiteres Beispiel für horizontale Verflechtungen sind gemeinsam genutzte Modelle in mehreren unabhängigen Abläufen - gemeinsame Nutzung von Ausnahmen, Validierungsregeln oder jede andere Form der Verflechtung in mehreren Abläufen.

<br />
    <div align=center>
        <img src="https://github.com/hassanhabib/The-Standard-German/blob/main/0.%20Einleitung/Resources/Grunds%C3%A4tze/Grunds%C3%A4tze-Horizontal.png?raw=true" />
    </div>
<br />

##### 0.2.0.0.1.1. Vertikale Verflechtung
Dieser Grundsatz gilt auch für Szenarien, in denen Basiskomponenten verwendet werden. Sofern diese Basiskomponenten nicht nativ oder extern sind, werden sie in einem standardkonformen System nicht zugelassen. Lokale Basiskomponenten schaffen eine vertikale Verflechtungsebene, die die Wartbarkeit und Lesbarkeit des Codes beeinträchtigt. Vertikale Verflechtungen sind genauso schädlich wie `Commons`-Komponenten, da sie in jedem System einzelne Fehlerpunkte schaffen.

Verflechtungen (vertikal oder horizontal) hindern Ingenieure in jedem System (insbesondere Neulinge) daran, die Tiefe des Systems zu verstehen und sich seine Funktionalität vollständig anzueignen. Sie verhindern auch, dass Ingenieure die Möglichkeit haben, Ende-zu-Ende-Abläufe zu erstellen, wenn die Hälfte der Funktionalität vermutlich aus Gründen der Entwicklungsgeschwindigkeit und Einfachheit komponentisiert ist. 

<br />
    <div align=center>
        <img src="https://github.com/hassanhabib/The-Standard-German/blob/main/0.%20Einleitung/Resources/Grunds%C3%A4tze/Grunds%C3%A4tze-Vertical.png?raw=true" />
    </div>
<br />

#### 0.2.0.0.2 Autonome Komponenten
Jede Komponente in jedem System sollte autark sein. Jede Komponente implementiert ihre eigenen Validierungen, Werkzeuge und Hilfsprogramme in einer ihrer Dimensionen und ist nicht von anderen externen Komponenten abhängig, außer durch Abhängigkeitsinjektion. Dieser Grundsatz gibt der Duplizierung den Vorzug vor einer vermeintlichen Vereinfachung durch Codeverflechtung.

Autonome Komponenten eröffnen jedem Ingenieur in jedem Team die Möglichkeit, über alle Abhängigkeiten und Werkzeuge zu verfügen, die seine Komponente benötigt, um ihren Zweck zu erfüllen. Dies kann dazu führen, dass ein Teil des Codes dupliziert wird, um jedem Entwickler die Möglichkeit zu geben, zu lernen, wie man eine Komponente vollständig erstellt und weiterentwickelt.

##### 0.2.0.0.2.0 Keine Magie
Autonome Komponenten legen alle ihre Routinen offen, für den Entwickler sichtbar. Keine versteckten Routinen, gemeinsam genutzte Bibliotheken oder magische Erweiterungen, die eine Suche nach Referenzen erfordern, sobald eine unvermeidliche Aufspaltung des großen Monolithen einsetzt.

Wir werden Objekte so behandeln, wie sie in der Natur vorkommen: mehrdimensionale, in sich geschlossene Komponenten, wie Atome in der Natur. Diese Komponenten führen ihre eigenen Validierungen, Ausnahmebehandlungen, Verfolgungen, Sicherheit, Lokalisierung und alles andere durch.

<br />
	<div align=center>
		<img src="https://github.com/hassanhabib/The-Standard-German/blob/main/0.%20Einleitung/Resources/Grunds%C3%A4tze/Grunds%C3%A4tze.png?raw=true" />
	</div>
<br />

Komponenten, die nach dem Standard gebaut werden, halten sich strikt an die Idee von _What You See Is What You Get_ (WYSIWYG) - alles, was die Komponenten betrifft, wird auf der Komponente selbst stehen.

## 0.2.1 Wiederbeschreibbarkeit
Jedes System sollte unter Berücksichtigung des Prinzips der Wiederbeschreibbarkeit entwickelt werden. Das Prinzip besagt, dass unsere Annahmen in den Systemen, die wir entwickeln, das hohe Potenzial haben, erneut überprüft und möglicherweise überdacht zu werden. Jedes System sollte leicht umschreibbar sein, um den ständig wachsenden und sich ändernden Geschäftsanforderungen gerecht zu werden.

Wiederbeschreibbarer Code ist Code, der leicht zu verstehen, zu ändern und vollständig neu zu schreiben ist. Wiederbeschreibbarer Code ist extrem modular und autonom. Er ermutigt Ingenieure, ihn mit dem geringstmöglichen Aufwand und Risiko weiterzuentwickeln.

Umschreibbarer Code spielt dem Leser keine Streiche. Er sollte "plug-n-play" sein - forken, klonen, bauen und alle seine Tests erfolgreich und ohne Probleme durchführen. Es gibt keine versteckten Abhängigkeiten, injizierte Routinen zur Laufzeit oder unbekannte Vorbedingungen. 

## 0.2.2 Mono-Micro
Bauen Sie monolithische Systeme mit einer modularen Denkweise, bei der jeder Ablauf völlig unabhängig von anderen Abläufen ist. Zum Beispiel können wir ein monolithisches System mit einer Microservice-Mentalität aufbauen, was bedeutet, dass jeder Ablauf aus dem System extrahiert und mit dem geringstmöglichen Aufwand in einen eigenen Microservice oder Lambda verwandelt werden kann.

Dieses Prinzip geht Hand in Hand mit dem Konzept der autonomen Komponenten auf einer höheren Ebene, auf der die Abläufe auch autonom von ihren benachbarten Abläufen und ihrem Hostsystem sind.

## 0.2.3 Stufe Null
Der Code muss für einen Anfänger im Ingenieurberuf verständlich sein. Die meisten Ingenieure in unserer Branche werden immer Neulinge in diesem Bereich sein. Unsere Codebasis lebt davon, wie leicht sie für die meisten Ingenieure in der Branche zu verstehen ist.

Ingenieure der Stufe Null sind unser Maßstab für den Erfolg. Ihre Fähigkeit, unseren Code zu verstehen, ist unsere Versicherung, dass dieser Code auch in der nächsten Generation von Ingenieuren weiterleben und weiterentwickelt werden wird.

Dieser Grundsatz verlangt auch, dass jeder Ingenieur in der Branche seinen Code genau prüft und sich mit jüngeren Ingenieuren zusammenschließt, um zu sehen, ob sie diesen Grundsatz erfüllen.

## 0.2.4 Offener Code
Der Grundsatz des offenen Codes besagt, dass alles, was nach dem Standard geschrieben wurde, der Öffentlichkeit zugänglich sein sollte. Dies gilt für interne Architekturpraktiken, Testbibliotheken und jede andere Form der Modulentwicklung, die es nicht jedem Ingenieur ermöglicht, ein bestimmtes System zu erlernen und weiterzuentwickeln. Die Entwicklung interner Werkzeuge, die nicht zugänglich sind, schadet unweigerlich der Erfahrung derjenigen, die versuchen, genau diese Werkzeuge weiterzuentwickeln.

Das Prinzip erkennt auch an, dass man unter extremen Umständen, z.B. wenn die Sicherheit bedroht ist oder aufgrund einer vertraglichen Verpflichtung, Code, Werkzeuge, Plattformen und Muster nicht der Öffentlichkeit zugänglich machen kann. Es ist jedoch nicht erlaubt, den Quellcode ausschließlich zum persönlichen oder organisatorischen Vorteil zu nutzen.

## 0.2.5 Flugzeugmodus (Cloud-Foreign)
Der Standard setzt die Idee des Flugzeugmodus durch. Wenn Ingenieure ihre gesamte Infrastruktur auf ihrem lokalen Rechner einrichten können, ohne eine Netzwerkverbindung zu benötigen oder zu haben, widerspricht dieses Prinzip stark Prinzipien wie Cloud-Native-Anwendungen, bei denen ein bestimmtes System nicht ohne Cloud-Infrastruktur auskommt und läuft.

Der Standard ermutigt seine Anwender auch, geeignete Werkzeuge zu entwickeln, um die Lücke zwischen den Komponenten der Cloud-Infrastruktur und den lokalen Komponenten wie Warteschlangen, Event-Hubs und anderen Werkzeugen zu überbrücken, um sie leicht testbar und modifizierbar zu machen.

## 0.2.6 Keine Toaster
Der Standard soll von Mensch zu Mensch vermittelt werden, nicht von Maschine zu Mensch. Es sollten keine Stylecops oder Analyzer implementiert werden, um Menschen zu zwingen, den Standard zu befolgen. Er sollte von der Leidenschaft des Herzens und der Überzeugung des Verstandes getragen werden. Der Standard sollte von Menschen für Menschen gelehrt werden. Er soll eine Ingenieurskultur der offenen Diskussion, der Überzeugung und des Verständnisses fördern.

## 0.2.7 Weitergabe
Der Standard soll ohne Kosten gelehrt werden, so wie er bei Ihnen angekommen ist. Er sollte auch kostenlos an den nächsten Ingenieur weitergegeben werden, unabhängig von seinem finanziellen, sozialen oder Bildungsstatus. Der Standard ist reines Wissen, das von den Selbstlosen an die Selbstlosen weitergegeben wird. Es darf kein Profit daraus geschlagen werden, und es darf auch kein Grund sein, andere herabzusetzen oder ihnen das Gefühl zu geben, weniger Wert zu sein. Der Standard aus Profitgründen zu lehren, verstößt gegen ihn und verweigert dem Nutznießer (dem Verletzer) jegliche weitere Anleitung durch den Autor.