# 2.3 Orchestrierungsdienste (Komplexe Logik höherer Ordnung)

## 2.3.0 Einleitung

Orchestrierungsdienste sind die Kombinatoren zwischen mehreren Basis- oder Verarbeitungsdiensten zur Durchführung einer komplexen logischen Operation. Ihre Hauptaufgaben sind logische Operationen mit mehreren Entitäten und die Delegation der Abhängigkeiten dieser Operationen an nachgelagerte Verarbeitungs- oder Basisdienste.

Die Hauptaufgabe der Orchestrierungsdienste ist die Kapselung von Operationen, die zwei oder drei Geschäftseinheiten erfordern.

```csharp
public async ValueTask<LibraryCard> CreateStudentLibraryCardAsync(LibraryCard libraryCard) =>
TryCatch(async () =>
{
    ValidateLibraryCard(libraryCard);

    await this.studentProcessingService
        .VerifyEnrolledStudentExistsAsync(libraryCard.StudentId);

    return await this.libraryCardProcessingService.CreateLibraryCardAsync(libraryCard);
});

```

Im obigen Beispiel ruft der `LibraryCardOrchestrationService` sowohl den `StudentProcessingService` als auch den `LibraryCardProcessingService` auf, um eine komplexe Operation durchzuführen. Erstens: Überprüfung der Existenz des Schülers, für den wir einen Bibliotheksausweis erstellen, und Überprüfung der Einschreibung des Schülers; und zweitens: Erstellung des Bibliotheksausweises.

Die Erstellung eines Bibliotheksausweises für einen bestimmten Studenten kann nicht durch einen einfachen Aufruf des Dienstes für Bibliotheksausweise erfolgen, da der Dienst für Bibliotheksausweise (Verarbeitung oder Stiftung) nicht auf alle Einzelheiten über den Studenten zugreifen kann. Daher ist eine Kombinationslogik erforderlich, um einen ordnungsgemäßen Ablauf zu gewährleisten.

Es ist wichtig zu verstehen, dass Orchestrierungsdienste nur dann erforderlich sind, wenn wir Operationen mehrerer Entitäten kombinieren müssen, die primitiv oder höherwertig sein können. In einigen Architekturen gibt es möglicherweise nicht einmal Orchestrierungsdienste. Das liegt einfach daran, dass einige Microservices lediglich für die Anwendung der Validierungslogik und die Persistierung und den Abruf von Daten aus dem Speicher zuständig sind, nicht mehr und nicht weniger.

## 2.3.1 Auf der Landkarte

Orchestrierungsdienste sind eine der Kernkomponenten der Geschäftslogik in jedem System, die zwischen Diensten für einzelne Entitäten (wie Verarbeitung oder Basis) und erweiterten Logikdiensten wie Koordinationsdiensten, Aggregationsdiensten oder einfachen Exposees wie Controller-Webkomponenten oder anderen Dingen angesiedelt sind. Hier ist ein Überblick darüber, wo Orchestrierungsdienste angesiedelt sein können:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118414675-e4fc8b80-b65a-11eb-91c8-94f67c6e68ed.png" />
    </p>
<br />

Wie oben gezeigt, haben Orchestrierungsdienste eine ganze Reihe von Abhängigkeiten und Verbrauchern. Sie sind der Kernmotor jeder Software. Auf der rechten Seite sehen Sie die Abhängigkeiten eines Orchestrierungsdienstes. Da ein Verarbeitungsdienst optional ist, je nachdem, ob eine übergeordnete Geschäftslogik benötigt wird oder nicht, können Orchestrierungsdienste auch mehrere Basisdienste kombinieren.

Das Vorhandensein eines Orchestrierungsdienstes garantiert das Vorhandensein eines Verarbeitungsdienstes. Das ist aber nicht immer der Fall. Es gibt Situationen, in denen alle Orchestrierungsdienste einen Geschäftsablauf abschließen müssen, um mit den Funktionen der Basisebene zu interagieren.

Ein Orchestrierungsdienst kann jedoch mehrere Verbraucher haben, z. B. Koordinationsdienste (Orchestrierungsdienste von Orchestrierungsdiensten), Aggregationsdienste oder einfach einen Exposer. Exposer sind z. B. Controller, View-Dienste, UI-Komponenten oder ein anderer Basis- oder Verarbeitungsdienst, wenn es darum geht, Nachrichten in eine Warteschlange zu stellen - worauf wir in unserem Standard noch eingehen werden.

## 2.3.2 Merkmale

Im Allgemeinen geht es bei Orchestrierungsdiensten um die Kombination von primitiven oder übergeordneten Geschäftslogik-Operationen einzelner Einheiten, um einen erfolgreichen Ablauf zu erreichen. Man kann sie aber auch als den Klebstoff betrachten, der mehrere Single-Entity-Operationen miteinander verbindet.

### 2.3.2.0 Sprache

Wie bei den verarbeitenden Diensten bestimmt auch bei den Orchestrierungsdiensten die verwendete Sprache den Grad der Komplexität und die Möglichkeiten, die sie bieten.
In der Regel kombinieren Orchestrierungsdienste zwei oder mehr primitive oder höherwertige Operationen aus mehreren Single-Entity-Diensten, um eine erfolgreiche Operation auszuführen.

#### 2.3.2.0.0 Funktionen Sprache

Orchestrierungsdienste haben ein gemeinsames Merkmal hinsichtlich der Sprache ihrer Funktionen. Orchestrierungsdienste sind in den meisten Fällen in der Sprache ihrer Funktionen ganzheitlich. Sie werden Funktionen wie `NotifyAllAdmins` sehen, wo der Dienst alle Benutzer mit einem Admin-Typ abruft und dann einen Benachrichtigungsdienst aufruft, um sie zu benachrichtigen.

Orchestrierungsdienste bieten Funktionen, die sich immer mehr einer Geschäftssprache annähern als einer primitiven technischen Bedienung. Es kann vorkommen, dass ein Funktionsname in einem Orchestrierungsdienst mit einem fast identischen Ausdruck in einer nichttechnischen Geschäftsanforderung übereinstimmt. Das gleiche Muster setzt sich fort, wenn man zu höheren und fortgeschritteneren Kategorien von Diensten innerhalb dieses Bereichs der Geschäftslogik übergeht.

#### 2.3.2.0.1 Durchreichen (Pass-Through)

Orchestrierungsdienste können auch ein Pass-Through für einige Dienste sein. Ein Orchestrierungsdienst könnte es beispielsweise ermöglichen, dass ein "AddStudentAsync" über den Dienst weitergegeben wird, um die Quelle der Interaktionen mit dem System auf der Ebene des Exposees zu vereinheitlichen. In diesem Fall verwenden die Orchestrierungsdienste dieselbe Terminologie, die ein Verarbeitungs- oder Basisdienst zur Weitergabe des Vorgangs verwenden kann.

#### 2.3.2.0.2 Sprache auf Klassenebene

Orchestrierungsdienste kombinieren hauptsächlich mehrere Operationen, die eine bestimmte Entität unterstützen. Wenn also die primäre Entität `Student` ist und der Rest der Entitäten nur dazu dient, eine Operation zu unterstützen, die hauptsächlich auf die Entität `Student` abzielt, dann würde der Name des Orchestrierungsdienstes `StudentOrchestrationService` lauten.

Die Durchsetzung von Namenskonventionen stellt sicher, dass jeder Orchestrierungsdienst auf die Verantwortung einer einzelnen Entität für mehrere andere unterstützende Entitäten ausgerichtet bleibt.

Zum Beispiel erfordert die Erstellung eines Bibliotheksausweises die Einschreibung des Schülers, auf den dieser Bibliotheksausweis verweist. In diesem Fall spiegelt der Name des Orchestrierungsdienstes seine primäre Entität, "LibraryCard", wider. Der Name unseres Orchestrierungsdienstes wäre dann `LibraryCardOrchestrationService`.

Das Gegenteil ist ebenfalls der Fall. Wenn die Anmeldung eines Schülers an einer Schule mit Vorgängen wie der Erstellung eines Bibliotheksausweises verbunden ist, muss in diesem Fall ein "StudentOrchestrationService" vorhanden sein, um einen "Schüler" und alle anderen zugehörigen Entitäten zu erstellen.

Die gleiche Idee gilt für alle Ausnahmen, die in einem Orchestrierungsdienst erzeugt werden, wie `StudentOrchestrationValidationException` und `StudentOrchestrationDependencyException`.

### 2.3.2.1 Abhängigkeiten

Wie bereits erwähnt, können Orchestrierungsdienste im Gegensatz zu Verarbeitungs- und Basis-Diensten aufgrund der Optionalität von Verarbeitungsdiensten ein breiteres Spektrum an Abhängigkeiten aufweisen. Daher können Orchestrierungsdienste Abhängigkeiten aufweisen, die von Basisdiensten oder optionalen Verarbeitungsdiensten bis hin zu übergreifenden Diensten wie Protokollierung oder anderen Utility Brokern reichen.

#### 2.3.2.1.0 Balance der Abhängigkeiten (Florance-Muster)

Eine grundlegende Regel für die Konsistenz und Ausgewogenheit von Orchestrierungsdiensten ist das "Florance-Muster", das vorschreibt, dass ein Orchestrierungsdienst keine Abhängigkeiten aus verschiedenen Betriebskategorien kombinieren darf.

Das bedeutet, dass ein Orchestrierungsdienst keine Basis- und Verarbeitungsdienste kombinieren kann. Die Abhängigkeiten müssen entweder alle Processing- oder alle Basis-Dienste sein. Diese Regel gilt jedoch nicht für Utility Broker-Abhängigkeiten.

Hier ist ein Beispiel für unausgewogene Abhängigkeiten eines Orchestrierungsdienstes:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118415856-9e5e5f80-b661-11eb-96db-a541f89ccee7.png" />
    </p>
<br />

Ein zusätzlicher verarbeitender Dienst ist erforderlich, um einen Durchgang zu einem untergeordneten Basisdienst zu schaffen, um die Architektur auszugleichen - die Anwendung des 'Florance Pattern' für Symmetrie würde unsere Architektur wie folgt aussehen lassen:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118415965-33f9ef00-b662-11eb-8538-59e5c728d308.png" />
    </p>
<br />

Die Anwendung des "Florance-Musters" kann anfangs sehr kostspielig sein, da es die Erstellung eines völlig neuen verarbeitenden Dienstes (oder mehrerer) beinhaltet, um die Architektur auszugleichen. Aber die Vorteile überwiegen die Kosten aus der Sicht der Wartbarkeit, der Lesbarkeit und der Plug-in-Fähigkeit.

#### 2.3.2.1.1 Zwei-Drei

Die "Zwei-Drei"-Regel ist eine Regel zur Komplexitätskontrolle. Diese Regel besagt, dass ein Orchestrierungsdienst nicht mehr als drei und nicht weniger als zwei Verarbeitungs- oder Basisdienste haben darf, um die Orchestrierung auszuführen. Diese Regel gilt jedoch nicht für Utility Broker. Ein Orchestrierungsdienst kann ohne weiteres einen `DateTimeBroker` oder einen `LoggingBroker` haben. Ein Orchestrierungsdienst darf jedoch keinen Entity Broker haben, wie z. B. einen `StorageBroker` oder einen `QueueBroker`, der direkt in die Kerngeschäftsschicht eines Dienstes einfließt.

Die "Zwei-Drei"-Regel kann eine Normalisierungsschicht für die kategorische Geschäftsfunktion erfordern. Lassen Sie uns über die verschiedenen Mechanismen zur Normalisierung von Orchestrierungsdiensten sprechen.

##### 2.3.2.1.1.0 Voll-Normalisierung

Es gibt häufig Situationen, in denen die aktuelle Architektur eines beliebigen Orchestrierungsdienstes in einem Orchestrierungsdienst mit drei Abhängigkeiten endet. Und ein neuer Entity Processing- oder Basis-Dienst ist erforderlich, um einen bestehenden Prozess zu vervollständigen.

Nehmen wir zum Beispiel an, wir haben einen "StudentContactOrchestrationService" und dieser Dienst hat Abhängigkeiten, die Funktionen auf primitiver Ebene für "Adresse", "E-Mail" und "Telefon" für jeden Studenten bereitstellen. Hier ist eine Visualisierung dieses Zustands:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120101834-f636a500-c0fc-11eb-968b-10ed9a60bac8.png" />
    </p>
<br />

Jetzt wird eine neue Anforderung, "SocialMedia", zu "Student" hinzugefügt, um mehr Kontaktinformationen darüber zu sammeln, wie ein Student zu erreichen ist. Wir können in den Modus der vollständigen Normalisierung übergehen, indem wir einfach eine gemeinsame Basis finden, die die Entitäten der Kontaktinformationen gleichmäßig aufteilt. So können wir z. B. reguläre Kontaktinformationen von digitalen Kontaktinformationen trennen, wie z. B. "Adresse" und "Telefon" von "E-Mail" und "SocialMedia". Auf diese Weise teilen wir vier Abhängigkeiten in zwei auf, jeweils für ihre Orchestrierungsdienste wie folgt:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120101983-c6d46800-c0fd-11eb-836a-496d191ef922.png" />
    </p>
<br />

In der obigen Abbildung haben wir den bestehenden `StudentContactOrchestrationService` in `StudentRegularContactOrchestrationService` geändert und eine seiner Abhängigkeiten vom `EmailService` entfernt.

Außerdem haben wir einen neuen `StudentDigitalContactOrchestrationService` erstellt, der zwei Abhängigkeiten vom bestehenden `EmailService` und dem neuen `SocialMediaService` hat. Folglich benötigen wir jetzt eine fortgeschrittene Geschäftslogik-Schicht, wie einen Koordinationsdienst, um Studenten-Kontaktinformationen für vorgelagerte Verbraucher bereitzustellen.

##### 2.3.2.1.1.1 Semi-Normalisierung

Die Normalisierung ist nicht immer so einfach wie im obigen Beispiel, vor allem dann nicht, wenn eine Kernentität vorhanden sein muss, bevor zusätzliche Informationen über verwandte Entitäten erstellt oder eingefügt werden können.

Nehmen wir zum Beispiel an, wir haben einen `StudentRegistrationOrchestrationService`, der auf `StudentProcessingService`, `LibraryCardProcessingService` und `BookProcessingService` wie folgt aufbaut:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120099527-c41f4600-c0f0-11eb-8702-1439f966d9dc.png" />
    </p>
<br />

Aber jetzt brauchen wir einen neuen Dienst, um die Impfdatensätze der Studenten als `ImmunizationProcessingService` zu bearbeiten. Wir brauchen alle vier Dienste, aber wir haben bereits einen `StudentRegistrationOrchestrationService`, der drei Abhängigkeiten hat. An diesem Punkt ist eine Semi-Normalisierung erforderlich, um die Architektur neu auszubalancieren, um die Zwei-Drei-Regel einzuhalten und schließlich die Komplexität zu kontrollieren.

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120100296-ea46e500-c0f4-11eb-888a-ed6668e9ffdb.png" />
    </p>
<br />

In diesem Fall ist eine weitere Normalisierung oder eine Aufteilung erforderlich, um die Architektur wieder ins Gleichgewicht zu bringen. Wir müssen konzeptionell über die Gemeinsamkeiten zwischen den primitiven Entitäten in einem Studentenregistrierungsprozess nachdenken. Die Anforderungen der Studenten umfassen Identität, Gesundheit und Materialien. In diesem Szenario können wir `LibraryCard` und `Book` unter demselben Orchestrierungsdienst zusammenfassen, da Bücher und Bibliotheken in gewisser Weise verwandt sind. Wir haben also `StudentLibraryOrchestrationService` und für den anderen Dienst würden wir `StudentHealthOrchestrationService` wie folgt verwenden:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120100597-68f05200-c0f6-11eb-9ccc-ae1c963f6de5.png" />
    </p>
 <br />

Um den Registrierungsfluss mit einem neuen Modell abzuschließen, muss ein Koordinierungsdienst eine erweiterte Geschäftslogik übergeben, um diese Entitäten zu kombinieren. Noch wichtiger ist jedoch, dass jeder Dienst eine redundante Abhängigkeit von `StudentProcessingService` hat, um sicherzustellen, dass keine virtuelle Abhängigkeit von einem anderen Dienst besteht, der einen Studentendatensatz erstellt/erzeugt.

Virtuelle Abhängigkeiten sind sehr knifflig. Es handelt sich um eine versteckte Verbindung zwischen zwei Diensten einer beliebigen Kategorie, bei der ein Dienst implizit davon ausgeht, dass eine bestimmte Entität erstellt wird und vorhanden ist. Virtuelle Abhängigkeiten sind sehr gefährlich und bedrohen die Eigenständigkeit eines jeden Dienstes. Die Erkennung virtueller Abhängigkeiten in einem frühen Stadium des Entwurfs- und Entwicklungsprozesses kann eine entmutigende, aber notwendige Aufgabe sein, um eine saubere, standardisierte Architektur zu gewährleisten.

Genauso wie Modelländerungen Datenbankstrukturmigrationen und zusätzliche Logik und Validierungen erfordern, könnte eine neue Anforderung für eine neue Entität eine Umstrukturierung einer bestehenden Architektur oder eine Erweiterung auf eine neue Version erfordern, je nachdem, in welchem Stadium das System diese neuen Anforderungen erhält.

Es mag sehr verlockend sein, eine weitere Abhängigkeit zu einem bestehenden Orchestrierungsdienst hinzuzufügen - aber das ist der Punkt, an dem das System beginnt, vom "Standard" abzuweichen. Und das ist der Punkt, an dem das System zu einem nicht mehr wartbaren Altsystem wird. Noch wichtiger ist jedoch, dass in diesem Szenario die Entwurfsprinzipien und die handwerklichen Standards der an der Konzeption und Entwicklung des Systems beteiligten Ingenieure auf die Probe gestellt werden.

##### 2.3.2.1.1.2 Nicht-Normalisierung

Ich glaube, dass alles, überall, irgendwie miteinander verbunden ist. Dennoch gibt es Szenarien, in denen ein höheres Maß an Normalisierung schwierig zu erreichen ist. Manchmal kann es für den Verstand unverständlich sein, mehrere Dienste unter einem Orchestrierungsdienst zusammenzufassen.

Es fällt mir nämlich schwer, mir ein Beispiel für mehrere Entitäten auszudenken, die keine Verbindung zueinander haben, da ich wirklich glaube, dass es so etwas nicht geben kann. Ich werde mich auf einige fiktive Entitäten verlassen, um ein Problem zu visualisieren. Nehmen wir also an, es gibt einen "AService" und einen "BService", die zusammen mit einem "XService" orchestriert sind. Die Existenz von `XService` ist wichtig, um sicherzustellen, dass sowohl `A` als auch `B` mit der Gewissheit erstellt werden können, dass eine Kernentität `X` existiert.

Nehmen wir nun an, dass ein neuer Dienst "CService" hinzugefügt werden muss, um den bestehenden Fluss zu vervollständigen. Jetzt haben wir also vier verschiedene Abhängigkeiten unter einem Orchestrierungsdienst, und eine Aufteilung ist obligatorisch. Da es keinerlei Beziehung zwischen `A`, `B` und `C` gibt, ist ein 'No-Normalization'-Ansatz die einzige Möglichkeit, ein neues Design wie folgt zu realisieren:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120102975-4d8b4400-c102-11eb-9582-6f95d17227e7.png" />
    </p>
 <br />

Jeder der oben genannten primitiven Dienste wird mit einem Kerndienst `X` orchestriert und dann in einem Koordinierungsdienst zusammengefasst. Der obige Fall ist das Worst-Case-Szenario, in dem eine Normalisierung jeglicher Größe unmöglich ist. Beachten Sie, dass der Autor dieser Norm kein realistisches Beispiel finden konnte, um Ihnen zu zeigen, wie selten diese Situation eintritt, so dass der Ansatz "Keine Normalisierung" Ihre allerletzte Lösung sein sollte, wenn Ihnen die Möglichkeiten ausgehen.

##### 2.3.2.1.1.3 Sinnvolle Aufgliederung
Unabhängig von der Art der Normalisierung, die Sie anwenden, müssen Sie sicherstellen, dass Ihre gruppierten Dienste eine gemeinsame Bedeutung haben. Wenn Sie zum Beispiel einen `StudentProcessingService` und einen `LibraryProcessingService` zusammenfassen, muss eine funktionale Gemeinsamkeit bestehen. Ein gutes Beispiel dafür wäre `StudentRegistrationOrchestrationService`, zum Beispiel. Der Registrierungsprozess erfordert das Hinzufügen eines neuen Studentendatensatzes und das Erstellen eines Bibliotheksausweises für eben diesen Studenten.

Die Implementierung von Orchestrierungsdiensten ohne Überschneidungen zwischen zwei oder drei Entitäten pro Vorgang verfehlt den gesamten Zweck eines Orchestrierungsdienstes. Diese Bedingung ist erfüllt, wenn mindestens eine Überschneidung zwischen zwei Entitäten stattgefunden hat. Ein Orchestrierungsdienst kann andere "Pass-Through"-Operationen haben, bei denen wir bestimmte Routinen von ihren Verarbeitungs- oder Basis-Ursprüngen weitergeben, wenn sie demselben Vertrag entsprechen.

Hier ist ein Beispiel:

```csharp
public class StudentOrchestrationService
{
    public async ValueTask<Student> RegisterStudentAsync(Student student)
    {
        Student addedStudent =
            await this.studentProcessingService.AddStudentAsync(student);
    
        LibraryCard libraryCard = 
            await this.libraryCardPorcessingService.AddLibraryCardAsync(
                addedStudent.Id);

        return addedStudent;
    }


    public async ValueTask<Student> ModifyStudentAsync(Student student) =>
        await this.studentProcessingService.ModifyStudentAsync(student);
}
```

Im obigen Beispiel hatte unser `StudentOrchestrationService` eine Orchestrierungsroutine, die das Hinzufügen eines Studenten und das Erstellen eines Bibliotheksausweises für diesen Studenten kombinierte. Darüber hinaus bietet er aber auch eine "Pass-Through"-Funktion für eine Dienstroutine der unteren Verarbeitungsebene zur Änderung eines Studenten.

Die "Pass-Through"-Routinen müssen denselben Vertrag haben wie die anderen Routinen in einem beliebigen Orchestrierungsdienst. Unser "Pure Contract"-Prinzip schreibt vor, dass jeder Dienst denselben Vertrag als Eingabe- und Ausgabe- oder primitive Typen zulassen sollte.

### 2.3.2.2 Verträge
Orchestrierungsdienste können zwei oder drei verschiedene Entitäten und deren Operationen kombinieren, um eine höhere Geschäftslogik zu erreichen. Es gibt zwei Szenarien für Verträge/Modelle für Orchestrierungsdienste: Eines, das dem Zweck der primären Entität treu bleibt, und eines, das komplexer ist - ein kombinierter Orchestrierungsdienst, der versucht, seine inneren Zielentitäten explizit offenzulegen.

Lassen Sie uns über diese beiden Szenarien im Detail sprechen.

#### 2.3.2.2.0 Physische Kontrakte
Einige Orchestrierungsdienste sind immer noch single-purposed, auch wenn sie zwei oder drei andere Routinen höherer Ordnung aus mehreren Entitäten kombinieren können. Ein Orchestrierungsdienst, der auf Nachrichten aus einer Warteschlange reagiert und diese Nachrichten dann persistiert, ist beispielsweise ein zweckgebundener Orchestrierungsdienst mit nur einer Entität.

Werfen wir einen Blick auf diesen Codeschnipsel:

```csharp

public class StudentOrchestrationService
{
    private readonly IStudentEventProcessingService studentEventProcessingService;
    private readonly IStudentProcessingService studentProcessingService;

    public StudentOrchestrationService(
        IStudentEventProcessingService studentEventProcessingService,
        IStudentProcessingService studentProcessingService)
    {
        this.studentEventProcessingService = studentEventProcessingService;
        this.studentProcessingService = studentProcessingService;
        ListenToEvents();
    }

    public void ListenToEvents() =>
        this.studentEventService.ListenToEvent(UpsertStudentAsync);

    public async ValueTask<Student> UpsertStudentAsync(Student student)
    {
        ...
        await this.studentProcessingService.UpsertStudentAsync(student);

        ...
    }
}
```

Im obigen Beispiel stellt der Orchestrierungsdienst immer noch Funktionen bereit, die das physische Modell "Student" berücksichtigen, und kommuniziert intern mit mehreren Diensten, die möglicherweise völlig andere Modelle bereitstellen. Dies sind die Szenarien, in denen eine einzelne Entität einen primären Zweck hat und alle anderen Dienste unterstützende Dienste sind, um einen erfolgreichen Ablauf für diese Entität zu gewährleisten.

In unserem Beispiel _hören_ die Orchestrierungsdienste auf eine Warteschlange für Nachrichten über neue Studenten und verwenden dann dieses Ereignis, um alle neuen Studenten im System zu halten. Der physische Vertrag `Student` ist also dieselbe Sprache, die der Orchestrierungsdienst explizit als Modell für die Kommunikation mit oberen Stream-Diensten/Exposern oder anderen verwendet.

Es gibt aber auch andere Szenarien, in denen eine einzelne Entität nicht der einzige Zweck/Zielpunkt für einen Orchestrierungsdienst ist. Lassen Sie uns darüber im Detail sprechen.

#### 2.3.2.2.1 Virtuelle Verträge
In einigen Szenarien kann es erforderlich sein, dass ein Orchestrierungsdienst nicht-physische Verträge erstellt, um einen bestimmten Vorgang abzuschließen. Nehmen wir zum Beispiel einen Orchestrierungsdienst, der einen Social-Media-Beitrag mit einem Bild aufrechterhalten soll. Die Anforderung besteht hier darin, das Bild in einer Datenbank und den eigentlichen Beitrag (Kommentare, Autoren und andere) in einer anderen Datenbanktabelle in einem relationalen Modell zu speichern.

Das eingehende Modell kann sich erheblich von den tatsächlichen physischen Modellen unterscheiden. Schauen wir uns einmal an, wie das in der Praxis aussehen würde.

Nehmen wir an, wir hätten dieses Modell:

```csharp
public class MediaPost
{
    public Guid Id {get; set;}
    public string Content {get; set;}
    public DateTimeOffset Date {get; set;}
    public IEnumerable<string> Base64Images {get; set;}
}
```

Der obige Vertrag `MediaPost` enthält zwei verschiedene physische Einheiten. Die erste ist der eigentliche Beitrag, einschließlich `Id`, `Inhalt` und `Datum`, und die zweite ist die Liste der Bilder, die diesem Beitrag zugeordnet sind.

So würde ein Orchestrierungsdienst auf dieses eingehende virtuelle Modell reagieren:

```csharp
public async ValueTask<MediaPost> SubmitMediaPostAsync(MediaPost mediaPost)
{
    ...

    Post post = MapToPost(mediaPost);
    List<Media> medias = MapToMedias(mediaPost);

    Post addedPost =
        await this.postProcessingService.AddPostAsync(post);
    
    List<Medias> addedMedias = 
        await this.mediaProcessingService.AddMediasAsync(medias);

    return MapToMediaPost(addedPost, addedMedias); 
}

public Post MapToPost(MediaPost mediaPost)
{
    return new Post
    {
        Id = mediaPost.Id,
        Content = mediaPost.Content,
        CreatedDate = mediaPost.Date,
        UpdatedDate = mediaPost.Date
    };
}

public List<Media> MapToMedias(MediaPost mediaPost)
{
    return mediaPost.Base64Images.Select(image =>
        new Media
        {
            Id = Guid.NewGuid(),
            PostId = mediaPost.Id,
            Image = image,
            CreatedDate = mediaPost.Date,
            UpdatedDate = mediaPost.Date
        });
}
```

Das obige Codeschnipsel zeigt, wie der Orchestrierungsdienst ein gegebenes virtuelles Modell/Vertrag `MediaPost` in zwei physische Modelle zerlegt. Für jedes Modell gibt es einen eigenen verarbeitenden Dienst, der die Persistenz sicherstellt. Es gibt Szenarien, in denen das virtuelle Modell in ein einziges Modell zerlegt wird, wobei zusätzliche Details für die Validierung und Überprüfung durch nachgelagerte Verarbeitungs- oder Basisdienste verwendet werden.

Es gibt auch hybride Situationen, in denen das eingehende virtuelle Modell verschachtelte physische Modelle haben kann, was wir nur bei virtuellen Modellen zulassen können. Physikalische Modelle müssen stets anämisch (sie enthalten keine Routinen oder Konstruktoren) und flach (sie enthalten keine verschachtelten Modelle) bleiben, um die Komplexität zu kontrollieren und die Verantwortung zu konzentrieren.

Zusammenfassend lässt sich sagen, dass Orchestrierungsdienste ihre eigenen Verträge erstellen können. Diese Verträge können physisch oder virtuell sein. Und ein virtueller Vertrag kann eine Kombination aus einem oder mehreren physischen (oder verschachtelten virtuellen) Verträgen sein oder hat einfach ein eigenes flaches Design in Bezug auf die Eigenschaften.

### 2.3.2.2 Cul-De-Sac
Manchmal benötigen Orchestrierungsdienste und ihre Äquivalente (Koordination, Management usw.) keine Exposer-Komponente (z. B. Controller). Der Grund dafür ist, dass diese Dienste als Hörer für bestimmte Ereignisse fungieren und das Ereignis an einen Verarbeitungs- oder Basis-Dienst auf derselben Ebene zurückmelden, auf der das Ereignis begonnen hat oder empfangen wurde.

Eingehende Nachrichten können zum Beispiel von einem Abonnement eines Ereignisdienstes oder einer Warteschlange empfangen werden. In diesem Fall erfolgt der Input für diese Dienste nicht mehr zwangsläufig über eine Exposure-Komponente. Stellen Sie sich eine einfache Anwendung vor, die mit Nachrichten aus einer Warteschlange benachrichtigt wird und diese Nachrichten dann in einem lokalen Modell abbildet, um sie im Speicher zu halten. In diesem Fall würde der Orchestrierungsdienst etwa wie folgt aussehen:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/144501231-11ea13c9-81fa-4730-8840-a891a1d9edde.png" />
    </p>
 <br />

 Der `StudentEventOrchestrationService` hört auf Nachrichten über neu eintreffende Studenten und wandelt diese sofort in Modelle um, die in der Datenbank persistiert werden können.

 Hier ist ein Beispiel:

 Beginnen wir mit einem Unit-Test für dieses Muster wie folgt:
 
 ```csharp
[Fact]
public void ShouldListenToProfileEvents()
{
    // given . when
    this.profileEventOrchestrationService.ListenToProfileEvents();

    // then
    this.profileEventServiceMock.Verify(service =>
        service.ListenToProfileEvent(
            this.profileEventOrchestrationService.ProcessProfileEventAsync),
                Times.Once);

    this.profileEventService.VerifyNoOtherCalls();
    this.profileServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
}

[Fact]
public async Task ShouldAddProfileAsync()
{
    // given
    ProfileEvent randomProfileEvent =
        CreateRandomProfileEvent();

    ProfileEvent inputProfileEvent =
        randomProfileEvent;

    this.profileServiceMock.Setup(service =>
        service.AddProfileAsync(inputProfileEvent.Profile));

    // when
    await this.profileEventOrchestrationService
        .ProcessProfileEventAsync(inputProfileEvent);

    // then
    this.profileServiceMock.Verify(service =>
        service.AddProfileAsync(inputProfileEvent.Profile),
            Times.Once);

    this.profileServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
    this.profileEventServiceMock.VerifyNoOtherCalls();
}
 ```

 Der Test hier zeigt, dass zuerst ein Ereignis abgehört werden muss, dann muss die Persistenzlogik im studentischen Dienst mit dem Ergebnis der Zuordnung einer eingehenden Nachricht zu einem bestimmten Studenten übereinstimmen.

 Versuchen wir, diesen Test erfolgreich zu machen.

 ```csharp
public partial class ProfileEventOrchestrationService : IProfileEventOrchestrationService
{
    private readonly IProfileEventService profileEventService;
    private readonly IProfileService profileService;
    private readonly ILoggingBroker loggingBroker;

    public ProfileEventOrchestrationService(
        IProfileEventProcessingService profileEventService,
        IProfileProcessingService profileService,
        ILoggingBroker loggingBroker)
    {
        this.profileEventService = profileEventService;
        this.profileService = profileService;
        this.loggingBroker = loggingBroker;
    }

    public void ListenToProfileEvents() =>
    TryCatch(() =>
    {
        this.profileEventService.ListenToProfileEvent(
            ProcessProfileEventAsync);
    });

    public ValueTask ProcessProfileEventAsync(ProfileEvent profileEvent) =>
    TryCatch(async () =>
    {
        ...

        await this.profileService.AddProfileAsync(profileEvent.Profile);
    });
}
 ```


Im obigen Beispiel abonniert der Konstruktor des Orchestrierungsdienstes die Ereignisse, die vom `StudentEventService` kommen würden. Wenn ein Ereignis eintritt, ruft der Orchestrierungsdienst die Funktion `ProcessingIncomingStudentMessageAsync` auf, um den eingehenden Studenten über eine Basis oder einen Verarbeitungsdienst auf derselben Ebene wie der Ereignisdienst in der Datenbank zu halten.

Dieses Muster oder Merkmal wird als "Cul-De-Sac" bezeichnet. Eine eingehende Nachricht dreht sich um und geht in eine andere Richtung für eine andere Abhängigkeit. Dieses Muster ist typisch für große Anwendungen auf Unternehmensebene, bei denen die letztendliche Konsistenz gewährleistet werden muss, damit das System skaliert werden kann und auch bei hoher Auslastung belastbar ist. Dieses Muster verhindert auch böswillige Angriffe auf Ihre API-Endpunkte, da es die Verarbeitung von Warteschlangenmeldungen oder Ereignissen immer dann ermöglicht, wenn der Dienst bereit ist, sie zu verarbeiten. Wir werden die Details in 'Die Standardarchitektur' besprechen.

## 2.3.3 Verantwortlichkeiten
Orchestrierungsdienste bieten eine erweiterte Geschäftslogik. Sie orchestrieren mehrere Abläufe für mehrere Entitäten/Modelle, um einen einzigen Ablauf abzuschließen. Lassen Sie uns im Detail besprechen, was diese Verantwortlichkeiten sind:

### 2.3.3.0 Erweiterte Logik
Orchestrierungsdienste können nicht existieren, ohne mehrere Routinen von mehreren Entitäten zu kombinieren. Diese Entitäten können sich in ihrer Art unterscheiden, haben aber einen gemeinsamen Ablauf oder Zweck. So unterscheidet sich z. B. das Modell "LibraryCard" grundlegend von dem Modell "Student". Beide haben jedoch einen gemeinsamen Zweck in Bezug auf den Prozess der Studentenregistrierung. Das Hinzufügen eines Studentendatensatzes ist erforderlich, um einen Studenten zu registrieren, aber die Zuweisung eines Bibliotheksausweises an diesen Studenten ist für einen erfolgreichen Registrierungsprozess erforderlich.

Orchestrierungsdienste stellen sicher, dass die richtigen Routinen für jede Entität integriert sind, aber auch, dass diese Routinen in der richtigen Reihenfolge aufgerufen werden. Darüber hinaus sind die Orchestrierungsdienste für das Rollback eines fehlgeschlagenen Vorgangs verantwortlich. Diese drei Aspekte machen einen Orchestrierungsaufwand über mehrere Routinen, Entitäten oder Verträge hinweg aus.

Lassen Sie uns diese im Detail besprechen.

#### 2.3.3.0.0 Ablaufkombinationen
Wir haben bereits über Orchestrierungsdienste gesprochen, die mehrere Routinen kombinieren, um einen gemeinsamen Zweck oder einen einzigen Ablauf zu erreichen. Dieser Aspekt von Orchestrierungsdiensten kann sowohl als grundlegende Eigenschaft als auch als Verantwortung dienen. Ein Orchestrierungsdienst ohne mindestens eine Routine, die zwei oder drei Entitäten kombiniert, gilt nicht als Orchestrierung. Die Integration mit mehreren Diensten ohne einen gemeinsamen Zweck ist eine besser geeignete Definition für Aggregationsdienste, die wir später in diesem Kapitel über Dienste besprechen werden.

Aber innerhalb der Flow-Kombination kommt die Vereinheitlichung des Vertrags. Ich nenne dies Mapping und Branching. Das Mapping eines eingehenden Modells in mehrere Modelle von Diensten mit niedrigerem Durchsatz und die anschließende Verzweigung der Verantwortung zwischen diesen Diensten.

Genau wie die vorangegangenen Dienste sind die Orchestrierungsdienste während ihrer Flow-Kombination dafür verantwortlich, die Reinheit der offengelegten Eingabe- und Ausgabeverträge sicherzustellen, was bei der Kombination mehrerer Modelle etwas komplexer wird. Orchestrierungsdienste sind weiterhin für die Zuordnung eingehender Verträge zu ihren jeweiligen nachgelagerten Diensten verantwortlich. Sie werden auch die von diesen Diensten zurückgegebenen Ergebnisse in das vereinheitlichte Modell zurückführen.

Zur Veranschaulichung dieses Aspekts greifen wir auf ein früheres Codeschnipsel zurück:

```csharp
public async ValueTask<MediaPost> SubmitMediaPostAsync(MediaPost mediaPost)
{
    ...

    Post post = MapToPost(mediaPost);
    List<Media> medias = MapToMedias(mediaPost);

    Post addedPost =
        await this.postProcessingService.AddPostAsync(post);
    
    List<Medias> addedMedias = 
        await this.mediaProcessingService.AddMediasAsync(medias);

    return MapToMediaPost(addedPost, addedMedias); 
}

private Post MapToPost(MediaPost mediaPost)
{
    return new Post
    {
        Id = mediaPost.Id,
        Content = mediaPost.Content,
        CreatedDate = mediaPost.Date,
        UpdatedDate = mediaPost.Date
    };
}

private List<Media> MapToMedias(MediaPost mediaPost)
{
    return mediaPost.Base64Images.Select(image =>
        new Media
        {
            Id = Guid.NewGuid(),
            PostId = mediaPost.Id,
            Image = image,
            CreatedDate = mediaPost.Date,
            UpdatedDate = mediaPost.Date
        });
}

private MediaPost MapToMediaPost(Post post, List<Media> medias)
{
    return new MediaPost
    {
        Id = post.Id,
        Content = post.Content,
        Date = post.CreatedDate,
        Base64Images = medias.Select(media => media.Image)
    }
}
```

Wie Sie im obigen Beispiel sehen können, finden die Zuordnung und die Verzweigung nicht nur auf dem Weg nach innen statt. Auf dem Weg nach draußen muss jedoch eine umgekehrte Aktion durchgeführt werden. Es verstößt gegen den Standard, das gleiche Eingabeobjekt zurückzugeben, das übergeben wurde. Dadurch wird jede Sichtbarkeit möglicher Änderungen an der eingehenden Anfrage während der Persistenz genommen. Das Duplex-Mapping sollte die Notwendigkeit der Dereferenzierung der eingehenden Anfrage ersetzen, um sicherzustellen, dass keine unerwarteten internen Änderungen stattgefunden haben.

Es wird auch empfohlen, die Mapping-Logik in eine eigene Aspekt-/Teilklassendatei auszulagern. Etwas wie `StudentOrchestrationService.Mappings.cs`, um sicherzustellen, dass nur die Geschäftslogik der Orchestrierung übrig bleibt.

#### 2.3.3.0.1 Aufrufreihenfolge
Der Aufruf von Routinen in der richtigen Reihenfolge kann für jeden Orchestrierungsprozess entscheidend sein. So kann beispielsweise ein Bibliotheksausweis nur dann erstellt werden, wenn zuvor ein Studentendatensatz erstellt wurde. Die Einhaltung der Reihenfolge kann auf zwei verschiedene Arten erfolgen. Lassen Sie uns ein wenig über diese sprechen.

##### 2.3.3.0.1.0 Natürliche Ordnung
Die natürliche Reihenfolge bezieht sich hier auf bestimmte Abläufe, die erst dann ausgeführt werden können, wenn eine Voraussetzung von Eingabeparametern abgerufen oder beibehalten wurde. Stellen Sie sich zum Beispiel eine Situation vor, in der ein Bibliotheksausweis nicht erstellt werden kann, wenn nicht zuerst die eindeutige Kennung eines Studenten abgerufen wird. In diesem Fall brauchen wir uns nicht darum zu kümmern, dass bestimmte Routinen in der richtigen Reihenfolge aufgerufen werden, denn das ergibt sich von selbst aus dem Ablauf.

Hier ist ein Codebeispiel für diese Situation:

```csharp
public async ValueTask<LibraryCard> CreateLibraryCardAsync(LibraryCard libraryCard)
{
    Student student = await this.studentProcessingService
        .RetrieveStudentByIdAsync(libraryCard.StudentId));

    return await this.libraryCardProcessingService
        .CreateLibraryCardAsync(libraryCard, student.Name);
}
```

Im obigen Beispiel ist der Name des Schülers eine Voraussetzung für die Erstellung eines Bibliotheksausweises. Daher ergibt sich die Orchestrierung der Bestellung hier ganz natürlich als Teil des Ablaufs ohne zusätzlichen Aufwand.

Lassen Sie uns nun über die zweite Art von Ordnung sprechen - die erzwungene Ordnung.

##### 2.3.3.0.1.1 Erzwungene Bestellung
Stellen Sie sich dasselbe Beispiel wie oben vor, aber statt des Bibliotheksausweises, der den Namen des Schülers erfordert, braucht er nur die Schüler-"ID", die bereits im Modell der eingehenden Anfrage enthalten ist. Etwas wie dies:

```csharp
public async ValueTask<LibraryCard> CreateLibraryCardAsync(LibraryCard libraryCard)
{
    await this.studentProcessingService.VerifyEnlistedStudentExistAsync(
        libraryCard.StudentId);

    return await this.libraryCardProcessingService.CreateLibraryCardAsync(libraryCard);
}
```

Die Sicherstellung, dass ein verifizierter eingeschriebener Student existiert, bevor ein Bibliotheksausweis erstellt wird, kann zu einer Herausforderung werden, da es keine Abhängigkeit zwischen dem Rückgabewert einer Routine und den Eingabeparametern der nächsten gibt. Mit anderen Worten, es gibt nichts, was die Funktion `VerifyEnlistedStudentExistAsync` zurückgibt, was die Funktion `CreateLibraryCardAsync` in Bezug auf die Eingabeparameter interessieren würde.

In diesem Fall muss eine erzwungene Art von Ordnung durch Einheitstests implementiert werden. Ein Unit-Test für diese Routine müsste nicht nur überprüfen, ob die Abhängigkeit mit den richtigen Parametern aufgerufen wurde, sondern auch, ob sie in der richtigen _Reihenfolge_ aufgerufen wurden. Schauen wir uns einmal an, wie das implementiert werden könnte:

```csharp
[Fact]
public async Task ShouldCreateLibraryCardAsync()
{
    // given
    Student someStudent = CreateRandomStudent();
    LibraryCard randomLibraryCard = CreateRandomLibraryCard();
    LibraryCard inputLibraryCard = randomLibraryCard;
    LibraryCard createdLibraryCard = inputLibraryCard;
    LibraryCard expectedLibraryCard = inputLibraryCard.DeepClone();
    Guid studentId = inputLibraryCard.StudentId;
    var mockSequence = new MockSequence();

    this.studentProcessingServiceMock.InSequence(mockSequence).Setup(service =>
        service.VerifyEnlistedStudentExistAsync(studentId))
            .Returns(someStudent);

    this.libraryCardProcessingServiceMock.InSequence(mockSequence).Setup(service =>
        service.CreateLibraryCardAsync(inputLibraryCard))
            .ReturnsAsync(createdLibraryCard);

    // when
    LibraryCard actualLibraryCard = await this.libraryCardOrchestrationService
        .CreateLibraryCardAsync(inputLibraryCard);

    // then
    actualLibraryCard.Should().BeEquivalentTo(expectedLibraryCard);

    this.studentProcessingServiceMock.Verify(service =>
        service.VerifyEnlistedStudentExistAsync(studentId),
            Times.Once);

    this.libraryCardProcessingServiceMock.Verify(service =>
        service.CreateLibraryCardAsync(inputLibraryCard),
            Times.Once);

    this.studentProcessingServiceMock.VerifyNoOtherCalls();
    this.libraryCardProcessingServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
}

```

Aus dem obigen Beispiel geht hervor, dass das Mock-Framework hier verwendet wird, um sicherzustellen, dass beim Aufrufen dieser Abhängigkeiten eine bestimmte Reihenfolge erzwungen wird. Auf diese Weise erzwingen wir eine bestimmte Implementierung innerhalb einer bestimmten Methode, um sicherzustellen, dass nicht natürlich verbundene Abhängigkeiten nacheinander in der vorgesehenen Reihenfolge aufgerufen werden.

Wenn Orchestrierungsdienste die maximale Anzahl von Abhängigkeiten erreichen, ist es wahrscheinlicher, dass die Art der Reihenfolge eher erzwungen als natürlich ist.

#### 2.3.3.0.2 Abbildung von Ausnahmen (Wrapping & Unwrapping)
Diese Verantwortung ist den Flow-Kombinationen sehr ähnlich. Nur dass in diesem Fall die Orchestrierungsdienste alle Ausnahmen, die in einer ihrer Abhängigkeiten auftreten können, in einem einheitlichen kategorischen Ausnahmemodell zusammenfassen. Beginnen wir mit einer Illustration, wie dieses Mapping aussehen kann:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/145294325-0818a2dd-a017-43af-b1f0-fa5c93a9218c.png" />
    </p>
 <br />

In der obigen Abbildung sehen Sie, dass Validierungs- und Abhängigkeitsvalidierungsausnahmen, die von nachgelagerten Diensten ausgelöst werden, in eine einheitliche Abhängigkeitsausnahme auf der Orchestrierungsebene abgebildet werden. Auf diese Weise können vorgelagerte Verbraucher desselben Orchestrierungsdienstes die nächste Vorgehensweise auf der Grundlage eines kategorischen Ausnahmetyps statt vier oder im Falle von drei Abhängigkeiten sechs kategorischer Abhängigkeiten bestimmen.

Beginnen wir mit einem fehlgeschlagenen Test, um unsere Idee hier zu verwirklichen:

```csharp
public static TheoryData DependencyValidationExceptions()
{
    string exceptionMessage = GetRandomMessage();
    var innerException = new Xeption(exceptionMessage);

    var studentValidationException =
        new StudentValidationException(innerException);

    var studentDependencyValidationException =
        new StudentDependencyValidationException(innerException);

    var libraryCardValidationException =
        new LibraryCardValidationException(innerException);

    var libraryCardDependencyValidationException =
        new LibraryCardDependencyValidationException(innerException);

    return new TheoryData<Xeption>
    {
        studentValidationException,
        studentDependencyValidationException,
        libraryCardValidationException,
        libraryCardDependencyValidationException
    };
}


[Theory]
[MemberData(nameof(DependencyValidationExceptions))]
public async Task ShouldThrowDependencyValidationExceptionOnCreateIfDependencyValidationErrorOccursAndLogItAsync(
    Xeption dependencyValidationException)
{
    // given
    Student someStudent = CreateRandomStudent();

    var expectedStudentOrchestrationDependencyValidationException =
        new StudentOrchestrationDependencyValidationException(
            dependencyValidationException.InnerException as Xeption);

    this.studentServiceMock.Setup(service =>
        service.AddStudentAsync(It.IsAny<Student>()))
            .ThrowsAsync(dependencyValidationException);

    // when
    ValueTask<Student> addStudentTask =
        await this.studentOrchestrationService.AddStudentAsync(someStudent);

    StudentOrchestrationDependencyValidationException
        actualStudentOrchestrationDependencyValidationException =
                await Assert.ThrowsAsync<StudentOrchestrationDependencyValidationException>(
                    addStudentTask.AsTask);

    // then
    actualStudentOrchestrationDependencyValidationException.Should()
        .BeEquivalentTo(expectedStudentOrchestrationDependencyValidationException);

    this.studentServiceMock.Verify(service =>
        service.AddStudentAsync(It.IsAny<Student>()),
            Times.Once);

    this.loggingBrokerMock.Verify(broker =>
        broker.LogError(It.Is(SameExceptionAs(
            expectedStudentOrchestrationDependencyValidationException))),
                Times.Once);

    this.libraryCardServiceMock.Verify(service =>
        service.AddLibraryCard(It.IsAny<Guid>()),
            Times.Once);

    this.studentServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
    this.libraryCardServiceMock.VerifyNoOtherCalls();
}
```

Oben verifizieren wir, dass jeder unserer vier Ausnahmetypen in eine `StudentOrchestrationDependencyValidationException` abgebildet wird. Wir behalten die ursprüngliche lokalisierte Ausnahme als innere Ausnahme bei. Wir lösen jedoch die kategorische Ausnahme auf dieser Ebene auf, um das ursprüngliche Problem zu erhalten, wenn wir stromaufwärts gehen.

Diese Ausnahmen werden unter einer Abhängigkeitsvalidierungsausnahme abgebildet, da sie von einer Abhängigkeit oder einer Abhängigkeit von einer nachgelagerten Abhängigkeit stammen. Wenn beispielsweise ein Speicher-Broker eine Ausnahme auslöst, bei der es sich um eine Abhängigkeitsvalidierung handelt (z. B. `DuplicateKeyException`). Der benachbarte Dienst des Brokers würde dies in eine lokalisierte "StudentAlreadyExistException" abbilden und diese Ausnahme dann in eine kategorische Ausnahme des Typs "StudentDependencyValidationException" verpacken. Wenn diese Ausnahme stromaufwärts an die Verarbeitung oder einen Orchestrierungsdienst weitergegeben wird, verlieren wir die kategorische Ausnahme, da wir sie bereits im richtigen Zuordnungsbereich erfasst haben. Dann betten wir diese sehr lokalisierte Ausnahme weiterhin unter der aktuellen Ausnahme zur Validierung der Dienstabhängigkeit ein.

Lassen Sie uns versuchen, diesen Test zu bestehen:

```csharp
public partial class StudentOrchestrationService
{
    private delegate ValueTask<Student> ReturningStudentFunction();

    private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
    {
        try
        {
            return await returningStudentFunction();
        }
        catch (StudentValidationException studentValidationException)
        {
            throw CreateAndLogDependencyValidationException(studentValidationException);
        }
        catch (StudentDependencyValidationException studentDependencyValidationException)
        {
            throw CreateAndLogDependencyValidationException(studentDependencyValidationException);
        }
        catch (LibraryCardValidationException libraryCardValidationException)
        {
            throw CreateAndLogDependencyValidationException(libraryCardValidationException);
        }
        catch (LibraryCardDependencyValidationException libraryCardDependencyValidationException)
        {
            throw CreateAndLogDependencyValidationException(libraryCardDependencyValidationException);
        }
    }

    private StudentOrchestrationDependencyValidationException CreateAndLogDependencyValidationException(Xeption exception)
    {
        var studentOrchestrationDependencyValidationException =
            new StudentOrchestrationDependencyValidationException(exception.innerException as Xeption);

        this.loggingBroker.LogError(studentOrchestrationDependencyValidationException);

        throw studentOrchestrationDependencyValidationException;
    }
}
```

Jetzt können wir das `TryCatch` wie folgt verwenden:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student) =>
TryCatch(async () => 
{
    ...
    Student addedStudent = await this.studentService.AddStudentAsync(student);
    LibraryCard libraryCard = await this.libraryCard.AddLibraryCard(addedStudent.Id);

    return addedStudent;  
});
```

In der Implementierung sehen Sie, dass wir alle vier verschiedenen Arten von Validierungsausnahmen für externe nachgelagerte Dienste in einer kategorischen Ausnahme abgebildet und dann die innere Ausnahme für jede einzelne beibehalten haben.

Die gleiche Regel gilt für Abhängigkeitsausnahmen. Abhängigkeitsausnahmen können sowohl Dienst- als auch Abhängigkeitsausnahmen von nachgelagerten Diensten sein. Im obigen Beispiel kann der Aufruf eines studentischen Dienstes die Ausnahmen `StudentDependencyException` und `StudentServiceException` erzeugen. Diese kategorischen Ausnahmen werden aus ihrer kategorischen Schicht herausgelöst und ihre lokale Schicht wird in eine einheitliche neue kategorische Ausnahme auf Orchestrierungsebene unter "StudentOrchestrationDependencyException" verpackt. Das Gleiche gilt für alle anderen kategorischen Ausnahmen zur Abhängigkeit wie `LibraryCardDependencyException` und `LibraryCardServiceException`.

Es ist von entscheidender Bedeutung, lokalisierte Ausnahmen von nachgelagerten Diensten mit kategorischen Ausnahmen in der aktuellen Dienstschicht zu entpacken und zu verpacken, um die Konsistenz mit der Exposers-Schicht zu gewährleisten. Diese Ausnahmen können einfach behandelt und auf die Art der Exposer-Komponente abgebildet werden. Im Falle einer Exposer-Komponente vom Typ API-Controller würde die Zuordnung HTTP-Statuscodes ergeben. Im Fall von UI-Exposer-Komponenten würde sie einen für den Endbenutzer aussagekräftigen Text abbilden.

Wir werden weiter oben in diesem Standard erörtern, wann lokalisierte Details zu inneren Ausnahmen, bei denen Endbenutzer keine Maßnahmen ergreifen müssen, offengelegt werden, was ausschließlich für Ausnahmen auf Abhängigkeits- und Dienstebene gilt.

## 2.3.4 Variationen
Orchestrierungsdienste variieren je nachdem, wo sie in der gesamten Low-Level-Architektur stehen. Beispielsweise wird ein Orchestrierungsdienst, der von nachgelagerten Orchestrierungsdiensten abhängt, als Koordinationsdienst bezeichnet. Ein Orchestrierungsdienst, der mit mehreren Koordinationsdiensten als Abhängigkeiten arbeitet, wird als Verwaltungsdienst bezeichnet. Diese Varianten sind ein Orchestrierungsdienst mit übergeordneter Geschäftslogik.

 ### 2.3.4.0 Varianten Ebenen
Schauen wir uns die möglichen Varianten für Orchestrierungsdienste an und wo sie positioniert werden würden:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147461598-e7fe6b48-976a-4787-bd97-11e7faf131ee.png" />
    </p>
 <br />

 Nach meiner persönlichen Erfahrung musste ich nur selten auf einen Uber Management Dienst zurückgreifen. Die Beschränkung auf Abhängigkeiten und Variationen von orchestrierungsähnlichen Diensten soll den Ingenieuren helfen, die Komplexität ihrer Logik zu überdenken. Aber zugegeben, es gibt Situationen, in denen Komplexität eine absolute Notwendigkeit ist. Deshalb gibt es Uber-Management-Dienste als Option.

 Die folgende Tabelle soll als Leitfaden für die Entwicklung von Varianten von Orchestrierungsdiensten auf der Grundlage der jeweiligen Ebene dienen:

| Variante | Abhängigkeiten | Konsumenten | Komplexität |
|------------------------				|---------------------------		| ------------------------------------------| -----------|
| Orchestrations Services				| Foundation or Processing Services | Coordination Services     			    | Low    	 |
| Coordination Services				    | Orchestration Services 			| Management Services       			    | Medium     |
| Management Services					| Coordination Services          	| Uber Management Services			        | High       |
| Uber Management Services      		| Management Services               | Aggregation, Views or Exposer Components	| Very High	 |

 Die Orchestrierung von Diensten, die über Uber Management Services hinausgehen, würde eine tiefere Diskussion und eine ernsthafte Betrachtung der Gesamtarchitektur erfordern. Zukünftige Versionen des Standards könnten dieses Thema in dem, was ich "The Lake House" nenne, behandeln, aber das liegt außerhalb des Rahmens dieser Version des Standards.

 ### 2.3.4.1 Einheit der Arbeit
 Bei den Variationen von Orchestrierungsdiensten empfehle ich dringend, dem Konzept der Arbeitseinheit treu zu bleiben. Jede Anfrage kann nur eine Sache tun, einschließlich ihrer Voraussetzungen. Wenn Sie z. B. einen Schüler in einer Schule anmelden müssen, müssen Sie möglicherweise auch einen Erziehungsberechtigten, Kontaktinformationen und andere Details hinzufügen. Das Auslösen von Ereignissen für diese Aktionen kann die Komplexität des Ablaufs erheblich verringern und das Risiko von Fehlern in nachgelagerten Diensten reduzieren.

 Hier ist eine Visualisierung für einen komplexen Single-Thread-Ansatz:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147462984-84e6dabd-bf27-413a-8e79-2659a24c37c0.png" />
    </p>
 <br />

 Die obige Lösung ist eine funktionierende Lösung für die Einschreibung eines Schülers. Wir mussten Informationen über Erziehungsberechtigte, Bibliotheksausweise, Klassen usw. einbeziehen. Diese Abhängigkeiten können mit Hilfe von Ereignissen aufgelöst werden, so dass andere Dienste dort weitermachen können, wo die Single-Thread-Dienste aufhören, um den Registrierungsprozess fortzusetzen. Etwa so:


  <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147463233-466a055f-ce95-4911-92cd-7b173b2a37df.png" />
    </p>
  <br />

  Oben wird die eingehende Anfrage in Ereignisse umgewandelt, wobei jedes dieser Ereignisse seine Orchestrierungsdienste nach einem Sackgassenmuster benachrichtigt, wie in Abschnitt 2.3.2.2 erläutert. Das bedeutet, dass nicht mehr ein einzelner Thread für den Erfolg jeder Abhängigkeit im System verantwortlich ist. Stattdessen würde jeder Event-Listening-Broker seinen Prozess auf eine vereinfachte Art und Weise abwickeln.

  Dieser Ansatz garantiert dem Anfragenden keine sofortige Rückmeldung über Erfolg oder Misserfolg. Es handelt sich um ein Eventual-Consistency-Muster, bei dem der Client eine "Accepted"-Nachricht oder ein Äquivalent auf der Grundlage des Kommunikationsprotokolls erhält, um ihm mitzuteilen, dass ein Prozess begonnen hat. Dennoch gibt es keine Garantie für Ergebnisse, bis die gesamte Ereignislogik ausgeführt wurde.

  Es ist zu beachten, dass wir diesen Ereignissen eine zusätzliche Ebene der Ausfallsicherheit hinzufügen können, indem wir sie vorübergehend in Warteschlangen-ähnlichen Komponenten oder speicherbasierten Zwischenspeichern speichern, je nach der Kritikalität des Geschäfts.

  Allerdings ist ein Ansatz für eventuelle Konsistenz nicht immer eine gute Lösung, wenn der Client auf der anderen Seite auf eine Antwort wartet, insbesondere in kritischen Situationen, in denen eine sofortige Antwort erforderlich ist. Eine Lösung für dieses Problem sind Fire-n-Observe-Warteschlangen, die wir in einer zukünftigen Version von The Standard behandeln werden.
  
[*] [Einleitung zu Orchestrierungsdiensten](https://www.youtube.com/watch?v=OP6HcIpXduE)

[*] [Cul-De-Sac-Muster für Orchestrierungsdienste](https://www.youtube.com/watch?v=C8Sm1kSKF1o)

[*] [Cul-De-Sac-Muster für Koordinationsdienste](https://www.youtube.com/watch?v=8KZIw_IJC0U)
