# 2.1 Basis Dienste (Broker-Nachbarschaft)

## 2.1.0 Einleitung

Basis-Dienste sind der erste Kontaktpunkt zwischen Ihrer Geschäftslogik und den Brokern.

Im Allgemeinen sind die Broker-Nachbarschaftsdienste eine Mischung aus Geschäftslogik und einer Abstraktionsschicht für die Verarbeitungsvorgänge, in denen die übergeordnete Geschäftslogik abläuft, auf die wir im nächsten Abschnitt näher eingehen werden, wenn wir die Verarbeitungsdienste untersuchen.

Die Hauptaufgabe der Broker-Nachbarschaftsdienste besteht darin, sicherzustellen, dass die über das System eingehenden und ausgehenden Daten strukturell, logisch und extern validiert und überprüft werden.

Man kann sich die Broker-Nachbarschaftsdienste auch als eine zusätzliche Validierungsschicht zu den primitiven Operationen vorstellen, die die Broker bereits anbieten.

Wenn beispielsweise ein Speicher-Broker die Methode `InsertStudentAsync(Student student)` anbietet, dann wird der broker-neighboring Dienst etwas wie folgt anbieten:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
}
```

Damit sind die Nachbarschaftsdienste von Brokern nichts weiter als eine zusätzliche Validierungsschicht zu den bestehenden primitiven Operationen, die Broker bereits anbieten.

## 2.1.1 Auf der Karte

Die Broker-Nachbarschaftsdienste befinden sich zwischen Ihren Brokern und dem Rest Ihrer Anwendung, auf der linken Seite können übergeordnete Dienste zur Verarbeitung von Geschäftslogik, Orchestrierung, Koordination, Aggregation oder Managementdienste oder einfach nur ein Controller, eine UI-Komponente oder eine andere Technologie zur Datenexposition stehen.

<br/>
	<p align=center>
		<img src="https://user-images.githubusercontent.com/1453985/100716772-00eec800-336e-11eb-9064-8bfe2f8e3be2.png" />
	</p>
<br/>

## 2.1.2 Merkmale

Basis- oder Broker-Nachbarschaftsdienste haben im Allgemeinen sehr spezifische Merkmale, die ihre Entwicklung und Integration streng regeln.

Basis-Dienste konzentrieren sich im Allgemeinen mehr auf Validierungen als auf alles andere - ganz einfach, weil das ihr Zweck ist, um sicherzustellen, dass alle ein- und ausgehenden Daten im System in einem guten Zustand sind, damit das System sie sicher und ohne Probleme verarbeiten kann.

Im Folgenden werden die Merkmale und Regeln für die Dienste von Broker-Nachbarn beschrieben:

### 2.1.2.0 Nur Primitive

Broker-Nachbarschaftsdienste dürfen nicht mehrere primitive Operationen kombinieren, um eine übergeordnete Geschäftslogikoperation zu erreichen.

Broker-Nachbarschaftsdienste können z. B. keine _upsert_-Funktion (update und hinzufügen) anbieten, um eine `Auswahl`-Operation mit einer `Aktualisierungs`- oder `Einfüge`-Operation auf der Grundlage des Ergebnisses zu kombinieren, um sicherzustellen, dass eine Entität existiert und in einem beliebigen Speicher auf dem neuesten Stand ist.

Aber sie bieten eine Validierung und Ausnahmeverarbeitung (und Mapping) um die Abhängigkeitsaufrufe herum, hier ist ein Beispiel:

```csharp
public ValueTask<Student> AddStudentAsync(Student student) =>
TryCatch(async () =>
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

In der obigen Methode sehen Sie, dass dem Aufruf der Funktion `ValidateStudent` ein `TryCatch`-Block vorangestellt ist.
Der `TryCatch`-Block ist das, was ich als Exception Noise Cancellation-Muster bezeichne, das wir bald in diesem Abschnitt besprechen werden.

Die Validierungsfunktion stellt jedoch sicher, dass jede einzelne Eigenschaft der eingehenden Daten überprüft wird, bevor sie an die primitive Broker-Operation weitergegeben wird, die in diesem Fall `InsertStudentAsync` ist.

### 2.1.2.1 Integration einer einzigen Entität

Dienste stellen sicher, dass das Prinzip der einzigen Zuständigkeit umgesetzt wird, indem sie sich nicht mit anderen Entity Brokern integrieren, außer mit dem, den sie unterstützen.

Diese Regel gilt nicht notwendigerweise für unterstützende Broker wie `DateTimeBroker` oder `LoggingBroker`, da sie nicht speziell auf eine bestimmte Geschäftseinheit abzielen und fast generisch für das gesamte System sind.

Zum Beispiel kann ein `StudentService` mit einem `StorageBroker` integriert werden, solange er nur auf die Funktionalität abzielt, die von der Teilklasse in der Datei `StorageBroker.Students.cs` angeboten wird.

Basis Dienste sollten nicht mit mehr als einem Entity Broker jeglicher Art integriert werden, einfach weil dies die Komplexität der Validierung und Orchestrierung erhöht, was über den Hauptzweck des Dienstes, der einfach nur die Validierung ist, hinausgeht. Wir verlagern diese Verantwortung weiter auf die Dienste vom Typ "Orchestrierung", um sie zu bewältigen.

### 2.1.2.2 Geschäftssprache

Broker-Nachbarschaftsdienste sprechen eine primitive Geschäftssprache für ihre Dienste.
Ein Broker kann zum Beispiel eine Methode mit dem Namen "InsertStudentAsync" bereitstellen - die Entsprechung auf der Diensteschicht wäre "AddStudentAsync".

Im Allgemeinen müssen die meisten CRUD-Operationen von einer Speichersprache in eine Geschäftssprache umgewandelt werden, und dasselbe gilt für Nicht-Speicheroperationen wie Warteschlangen, z. B. sagen wir "PostQueueMessage", aber in der Geschäftsschicht sagen wir "EnqueueMessage".

Da die CRUD-Operationen in jedem System am häufigsten vorkommen, würde unsere Zuordnung zu diesen CRUD-Operationen wie folgt lauten:

| Broker | Dienste |
| ------- | :------: |
| Insert  |   Add    |
| Select  | Retrieve |
| Update  |  Modify  |
| Delete  |  Remove  |

Auf dem Weg zu Diensten mit höherer Geschäftslogik wird sich die Sprache der verwendeten Methoden eher an eine Geschäftssprache als an eine Technologiesprache anlehnen, wie wir in den nächsten Abschnitten sehen werden.

## 2.1.3 Verantwortlichkeiten

Broker-Nachbarschaftsdienste spielen in jedem System drei sehr wichtige Rollen.
Die erste Rolle besteht darin, die nativen Broker-Operationen vom Rest des Systems zu abstrahieren. Unabhängig davon, ob es sich bei einem Broker um eine Kommunikation zwischen einem lokalen oder externen Speicher oder einer API handelt - broker-nachbarliche Dienste werden immer denselben Vertrag/Verband haben, um obere Stream-Dienste wie Verarbeitung, Orchestrierung oder einfach Exposees wie Controller oder UI-Komponenten zu exponieren.
Die zweite und wichtigste Rolle besteht darin, zusätzlich zu den bestehenden primitiven Operationen, die ein Broker bereits anbietet, eine Validierungsschicht anzubieten, um sicherzustellen, dass die ein- und ausgehenden Daten gültig sind und vom System verarbeitet oder persistiert werden können.
Die dritte Rolle ist die eines Mappers für alle anderen nativen Modelle und Verträge, die zum Abschluss einer bestimmten Operation während der Zusammenarbeit mit einem Broker benötigt werden.
Basis Dienste sind der letzte Punkt der Abstraktion zwischen der Kerngeschäftslogik eines Systems und dem Rest der Welt, lassen Sie uns diese Rollen im Detail diskutieren.

### 2.1.3.0 Abstraktion

Die erste und wichtigste Aufgabe der Basis/Broker-Nachbarschaftsdienste besteht darin, eine Abstraktionsebene zwischen den Brokern und dem Rest Ihres Systems zu gewährleisten. Diese Abstraktion ist notwendig, um sicherzustellen, dass die reine Geschäftslogikschicht in jedem System verbal und funktional unabhängig von den Abhängigkeiten ist, auf die sich das System zur Kommunikation mit der Außenwelt stützt.

Lassen Sie uns das obige Prinzip an einem konkreten Beispiel veranschaulichen. Nehmen wir an, wir haben einen `StudentProcessingService`, der eine `UpsertStudentAsync`-Funktionalität implementiert. Irgendwo in dieser Implementierung gibt es eine Abhängigkeit von `AddStudentAsync`, die von einem `StudentService` als Basis-Dienst ausgesetzt und implementiert wird. Werfen Sie einen Blick auf dieses Snippet:

```csharp
public async ValueTask<Student> UpsertStudentAsync(Student student)
{
	...

	return await this.studentService.AddStudentAsync(student);
}
```

Der Vertrag zwischen einem Verarbeitungs- oder Orchestrierungsdienst und einem Basisdienst ist immer derselbe, unabhängig davon, welche Art von Implementierung oder welche Art von Brokern der Basisdienst verwendet.
Zum Beispiel könnte `AddStudentAsync` ein Aufruf an eine Datenbank oder einen API-Endpunkt sein oder einfach eine Nachricht in eine Warteschlange stellen. All dies hat keinerlei Auswirkungen auf die Implementierung des vorgelagerten Verarbeitungsdienstes. Hier ein Beispiel für drei verschiedene Implementierungen eines Basisdienstes, die nichts an der Implementierung der vorgelagerten Dienste ändern würden:

Mit einem Storage Broker:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...
	return await this.storageBroker.InsertStudentAsync(student);
}
```

Oder mit einem Queue Broker:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...

	return await this.queueBroker.EnqueueStudentAsync(student);
}
```

oder mit einem API-Broker:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...

	return await this.apiBroker.PostStudentAsync(student);
}
```

Hier ist eine Visualisierung dieses Konzepts:

<br />

<div align=center>
	<img width="75%" src="https://user-images.githubusercontent.com/1453985/128610577-ee926ee2-a589-4f77-bf9d-dbff63d1c20d.png" />
</div>

<br />

In all diesen Fällen kann sich die zugrundeliegende Implementierung ändern, aber der exponierte Vertrag bleibt für den Rest des Systems immer derselbe. Wir werden in späteren Kapiteln erörtern, wie die zentrale, agnostische und abstrakte Geschäftslogik Ihres Systems mit den Verarbeitungsdiensten beginnt und mit den Verwaltungs- oder Aggregationsdiensten endet.

#### 2.1.3.0.1 Implementierung

Betrachten wir ein reales Beispiel für die Implementierung einer einfachen Funktion "Hinzufügen" in einem Basis-Dienst. Nehmen wir an, wir haben den folgenden Vertrag für unseren `StudentService`:

```csharp
public IStudentService
{
	ValueTask<Student> AddStudentAsync(Student student);
}
```

Für den Anfang schreiben wir einen fehlgeschlagenen Test für unseren Dienst wie folgt:

```csharp
public async Task ShouldAddStudentAsync()
{
	// gegeben
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	Student storageStudent = inputStudent;
	Student expectedStudent = storageStudent.DeepClone();

	this.storageBrokerMock.Setup(broker =>
		broker.InsertStudentAsync(inputStudent))
			.ReturnsAsync(storageStudent);

	// wenn
	Student actualStudent =
		await this.studentService.AddStudentAsync(inputStudent);

	// dann
	actualStudent.Should().BeEquivalentTo(expectedStudent);

	this.storageBroker.Verify(broker =>
		broker.InsertStudentAsync(inputStudent),
			Times.Once);

	this.storageBroker.VerifyNoOtherCalls();
	this.loggingBroker.VerifyNoOtherCalls();
}
```

In dem obigen Test haben wir vier Variablen mit demselben Wert definiert. Jede Variable enthält einen Namen, der am besten zu dem Kontext passt, in dem sie verwendet werden soll. Zum Beispiel passt `inputStudent` am besten in die Position der Eingabeparameter, während `storageStudent` am besten zu dem passt, was vom Storage Broker zurückgegeben wird, nachdem ein Student erfolgreich persistiert wurde.

Sie werden auch feststellen, dass wir die Variable `expectedStudent` tief geklont haben, um sicherzustellen, dass keine Änderungen an dem ursprünglich übergebenen Schüler vorgenommen wurden. Nehmen wir zum Beispiel an, dass ein eingegebener Schülerwert für eines seiner Attribute intern in der Funktion "AddStudentAsync" geändert wurde. Diese Änderung wird nur dann einen fehlgeschlagenen Test auslösen, wenn wir die Variable `expectedStudent` aus den Eingabe- und Rückgabevariablen derefenzieren.

Wir simulieren die Antwort des Storage Brokers und führen unseren Testgegenstand `AddStudentAsync` aus. Dann überprüfen wir, ob der zurückgegebene Studentenwert `actualStudent` mit dem erwarteten Wert `expectedStudent` übereinstimmt, unabhängig von der Referenz.

Schließlich überprüfen wir, ob alle Aufrufe ordnungsgemäß ausgeführt wurden und keine weiteren Aufrufe an eine der Dienstabhängigkeiten erfolgt sind.

Damit dieser Test erfolgreich ist, schreiben wir eine Implementierung, die nur die Anforderungen des oben erwähnten Tests erfüllt:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student) =>
	await this.storageBroker.InsertStudentAsync(Student);
```

Mit dieser einfachen Implementierung sollte unser Test erfolgreich verlaufen. Es ist wichtig zu verstehen, dass jede Implementierung nur ausreichen sollte, um die Tests zu bestehen. Nicht mehr und nicht weniger.

### 2.1.3.1 Validierung

Basis Dienste müssen sicherstellen, dass ein- und ausgehende Daten vom und zum System in einem guten Zustand sind - sie spielen die Rolle eines Torwächters zwischen dem System und der Außenwelt, um sicherzustellen, dass die durchlaufenden Daten strukturell, logisch und extern gültig sind, bevor weitere Operationen durch vorgelagerte Dienste durchgeführt werden.
Die Reihenfolge der Validierungen ist hier sehr bewusst gewählt. Strukturelle Validierungen sind die billigsten aller drei Arten. Sie stellen sicher, dass ein bestimmtes Attribut oder ein Datenelement im Allgemeinen keinen Standardwert hat, wenn es benötigt wird. Das Gegenteil davon sind die logischen Validierungen, bei denen Attribute mit anderen Attributen der gleichen oder einer anderen Entität verglichen werden. Zusätzliche logische Validierungen können auch einen Vergleich mit einem konstanten Wert beinhalten, wie z. B. der Vergleich, dass das Alter eines Schülers nicht weniger als 5 Jahre betragen darf.
Sowohl die strukturellen als auch die logischen Validierungen kommen vor den externen. Wie bereits erwähnt, wollen wir nicht die Kosten für die Kommunikation mit einer externen Ressource, einschließlich der Latenzsteuer, tragen, wenn unsere Anfrage nicht in einem guten Zustand ist.
Wir sollten zum Beispiel nicht versuchen, ein "Student"-Objekt an eine externe API zu senden, wenn das Objekt "null" ist. Oder wenn das `Student`-Modell strukturell oder logisch ungültig ist.

Für alle Arten von Überprüfungen ist es wichtig zu verstehen, dass einige Überprüfungen den Kreislauf unterbrechen oder ein sofortiges Verlassen des aktuellen Flusses erfordern, indem sie in einigen Fällen eine Ausnahme auslösen oder einen Wert zurückgeben. Andere Validierungen wiederum sind kontinuierlich. Lassen Sie uns zunächst über diese beiden Unterkategorien von Validierungen sprechen.

#### 2.1.3.1.0 Kreislaufunterbrechende Validierungen

Circuit-Breaking-Validierungen erfordern ein sofortiges Verlassen des aktuellen Flusses. Wenn z.B. ein Objekt, das an eine Funktion übergeben wird, `null` ist, sind auf dieser Ebene keine weiteren Operationen erforderlich, außer dem Verlassen des aktuellen Ablaufs durch das Auslösen einer Ausnahme oder die Rückgabe eines Wertes irgendeines Typs. Hier ist ein Beispiel:
Nehmen wir in einem Validierungsszenario an, dass unserer Funktion `AddStudent` ein Student mit dem Wert `null` wie folgt übergeben wird:

```csharp
Student noStudent = null;

await this.studentService.AddStudentAsync(noStudent);
```

Unsere Funktion `AddStudentAsync` in diesem Szenario muss nun überprüfen, ob der übergebene Parameter `null` ist oder nicht, bevor wir mit anderen Arten von Überprüfungen oder der Geschäftslogik selbst fortfahren. Etwas wie dies:

```csharp
public Student AddStudentAsync(Student student) =>
TryCatch(async () =>
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

Die Anweisung, die hier im Mittelpunkt steht, ist die Funktion `ValidateStudent` und was sie tut. Hier ist ein Beispiel, wie diese Routine implementiert werden könnte:

```csharp
private void ValidateStudent(Student student)
{
	if(student ist null)
	{
		throw new NullStudentException();
	}
}
```

In der obigen Funktion haben wir uns entschieden, die Ausnahme sofort auszulösen, anstatt weiter zu gehen. Das ist ein Beispiel für die Unterbrechung der Validierung.

Aber bei Validierungen ist es nicht immer klug, den Kreislauf zu unterbrechen. Manchmal wollen wir alle Probleme innerhalb einer bestimmten Anfrage sammeln, bevor wir den Fehlerbericht an den Antragsteller zurückschicken. Lassen Sie uns darüber im nächsten Abschnitt sprechen.

#### 2.1.3.1.1 Kontinuierliche Validierungen

Kontinuierliche Validierungen sind das Gegenteil von Validierungen, die den Kreislauf unterbrechen. Sie unterbrechen nicht den Fluss der Validierungen, aber sie unterbrechen definitiv den Fluss der Logik. Mit anderen Worten: Kontinuierliche Validierungen stellen sicher, dass keine Geschäftslogik ausgeführt wird, aber sie stellen auch sicher, dass andere Validierungen desselben Typs weiterhin ausgeführt werden können, bevor der Stromkreis unterbrochen wird. Lassen Sie uns diese Theorie anhand eines Beispiels verdeutlichen:
Nehmen wir an, unser Studentenmodell sieht wie folgt aus:

```csharp
public class Student
{
	public Guid Id {get; set;}
	public string Name {get; set;}
}
```

Angenommen, das übergebene "Student"-Modell ist nicht null, aber es hat Standardwerte für alle seine Eigenschaften. Wir wollen alle diese Werte für beliebig viele Attribute/Eigenschaften dieses Objekts sammeln und einen vollständigen Bericht an den Anfragenden zurückgeben. So wird es gemacht.

#### 2.1.3.1.1.0 Upsertable-Ausnahmen

Ein Problem dieser Art erfordert eine spezielle Art von Ausnahmen, die es erlauben, alle Fehler in der Eigenschaft `Data` zu sammeln. Jede systemeigene Ausnahme enthält die Eigenschaft `Data`, die im Grunde ein Wörterbuch für Schlüssel/Wert-Paare ist, um weitere Informationen über die Probleme zu sammeln, die das Auftreten der Ausnahme verursacht haben.
Das Problem mit diesen systemeigenen Ausnahmen ist, dass sie keine systemeigene Unterstützung für Upsertion haben. Die Möglichkeit, an eine bestehende Liste von Werten für einen bestimmten Schlüssel zu einem beliebigen Zeitpunkt anzuhängen.
Hier ist eine native Implementierung des Einfügens von Werten in ein gegebenes Wörterbuch:

```csharp
var someException = new Exception();

if(someException.Data.Contains(someKey))
{
	(someException.Data[someKey] as List<string>)?.Add(someValue);
}
else
{
	someException.Data.Add(someKey, new List<string>{ someValue });
}
```

Diese Implementierung kann für Ingenieure ziemlich entmutigend sein, wenn sie darüber nachdenken und in ihrer Implementierung auf Dienstebene testen müssen. Es schien angemessener, eine einfache Bibliothek `Xeptions` einzuführen, um die obige Implementierung zu etwas so einfachem wie zu vereinfachen:

```csharp
var someException = new Xeption();
someException.UpsertData(someKey, someValue);
```

Jetzt, da wir diese Bibliothek nutzen können, ist das Problem der Implementierung von Upsertable-Ausnahmen gelöst. Das bedeutet, dass wir das Nötige haben, um unsere Validierungsfehler zu sammeln. Aber das ist nicht gut genug, wenn wir keinen Mechanismus haben, um den Kreislauf zu unterbrechen, wenn wir glauben, dass es an der Zeit ist, dies zu tun.
Wir können einfach die nativen Angebote verwenden, um die Unterbrechung des Stromkreises direkt wie folgt zu implementieren:

```csharp
if(someException.Data.Count > 0)
{
	throw someException;
}
```

Und obwohl dies leicht in jede bestehende Implementierung eingefügt werden kann. Es trug trotzdem nicht viel zum Gesamtbild des Codes bei. Daher habe ich mich entschlossen, es zu einem Teil der `Xeptions`-Bibliothek zu machen, um das Folgende zu vereinfachen:

```csharp
someException.ThrowIfContainsErrors();
```

Das wuerde unsere benutzerdefinierten Pruefungen etwa so aussehen lassen:

```csharp
public class InvalidStudentException : Xeption
{
	public InvalidStudentException()
		: base ("Der Schüler ist ungültig. Bitte beheben Sie die Fehler und versuchen Sie es erneut.")
	{ }
}
```

Aber mit kontinuierlichen Validierungen, der Prozess der Sammlung dieser Fehler vermittelt mehr als nur eine spezielle Ausnahme-Implementierung. Lassen Sie uns darüber im nächsten Abschnitt sprechen.

#### 2.1.3.1.1.1 Dynamische Regeln

Ein nicht-kreislaufbasierter oder kontinuierlicher Validierungsprozess erfordert die Fähigkeit, dynamische Regeln in beliebiger Anzahl oder Kapazität zu übergeben, um diese Validierungsfehler hinzuzufügen. Eine Validierungsregel ist eine dynamische Struktur, die meldet, ob die Regel in Bezug auf ihre Bedingung verletzt wurde, und auch die Fehlermeldung, die dem Endbenutzer gemeldet werden sollte, um ihm bei der Behebung des Problems zu helfen.

In einem Szenario, in dem wir sicherstellen wollen, dass eine bestimmte Id gültig ist, würde eine dynamische kontinuierliche Validierungsregel etwa so aussehen:

```csharp
private static dynamic IsInvalid(Guid id) => new
{
	Bedingung = id == Guid.Empty,
	Message = "Id ist erforderlich"
};
```

Jetzt meldet unsere Regel nicht nur, ob ein bestimmtes Attribut ungültig ist oder nicht. Sie enthält auch eine aussagekräftige, für den Menschen lesbare Meldung, die dem Nutzer des Dienstes hilft zu verstehen, warum genau dieses Attribut ungültig ist.

Es ist sehr wichtig, darauf hinzuweisen, welche Sprache die Ingenieure für die Validierungsmeldungen verwenden müssen. Es hängt alles von den potenziellen Nutzern Ihres Systems ab. Ein Nicht-Ingenieur wird eine Meldung wie `Text kann nicht null, leer oder Leerzeichen sein` nicht verstehen - `null` ist ein Begriff, der nicht sehr häufig verwendet wird. Ingenieure müssen eng mit ihrer "meatware" (den Menschen, die das System benutzen) zusammenarbeiten, um sicherzustellen, dass die Sprache für sie Sinn macht.

Dynamische Regeln ermöglichen es den Ingenieuren, sowohl ihre Eingaben als auch ihre Ausgaben zu ändern, ohne die bestehende Funktionalität zu beeinträchtigen, solange die "Null"-Werte durchgängig berücksichtigt werden. Hier ist eine weitere Manifestation einer dynamischen Validierungsregel:

```csharp
private static dynamic IsNotSame(
	Guid firstId,
	Guid secondId,
	string secondIdName) => new
{
	Bedingung = firstId != secondId,
	Message = $"Id ist nicht identisch mit {secondIdName}.",
	HelpLink = "/help/code1234"
};
```

Unsere dynamische Regel kann nun mehr Eingabeparameter und hilfreichere Informationen in Form von detaillierteren Ausnahmemeldungen mit Links zu hilfreichen Dokumentationsseiten oder Referenzen für Fehlercodes anbieten.

#### 2.1.3.1.1.2 Regeln & Validierungssammler

Jetzt haben wir die erweiterten Ausnahmen und die dynamischen Validierungsregeln. Es ist nun an der Zeit, alles zusammenzufügen, um eine unendliche Anzahl von Prüfregeln zu akzeptieren, ihre Ergebnisse zu untersuchen und schließlich den Stromkreis zu unterbrechen, wenn alle kontinuierlichen Prüfungen abgeschlossen sind:

```csharp
private void Validate(params (dynamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new InvalidStudentException();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertData(parameter, rule.Message);
		}
	}

	invalidStudentException.ThrowIfContainsErrors();
}
```

Die obige Funktion nimmt nun eine beliebige Anzahl von Überprüfungsregeln und die Parameter, gegen die die Regel läuft, prüft dann die Bedingungen und fügt den Fehlerbericht hoch. So können wir die obige Methode verwenden:

```csharp
private void ValidateStudent(Student student)
{
	Validate(
		(Regel: IsInvalid(student.Id), Parameter: nameof(student.Id)),
		(Regel: IsInvalid(Student.Name), Parameter: nameof(Student.Name)),
		(Regel: IsInvalid(Schüler.Note), Parameter: nameof(Schüler.Note))
	);
}
```

Diese Vereinfachung des Schreibens von Regeln und Validierungen ist das ultimative Ziel, um den Endbenutzern weiterhin einen Mehrwert zu bieten und gleichzeitig den Prozess der Entwicklung der Lösung für die Ingenieure selbst angenehm zu gestalten.

Lassen Sie uns nun tiefer in die Arten von Validierungen eintauchen, die unsere Systeme anbieten können, und wie man sie handhabt.

#### 2.1.3.1.2 Strukturelle Validierungen

Die erste dieser Schichten ist die strukturelle Validierung. Sie stellt sicher, dass bestimmte Eigenschaften eines bestimmten Modells oder eines primitiven Typs nicht in einem ungültigen strukturellen Zustand sind.

Zum Beispiel sollte eine Eigenschaft vom Typ "String" nicht leer, "null" oder ein Leerzeichen sein. Ein anderes Beispiel wäre ein Eingabeparameter vom Typ "int", der sich nicht in seinem "Standardzustand" befinden sollte, der "0" ist, wenn man versucht, ein Alter einzugeben.

Die strukturellen Überprüfungen stellen sicher, dass die Daten in einem guten Zustand sind, bevor wir mit weiteren Überprüfungen fortfahren - zum Beispiel können wir nicht überprüfen, ob ein Schüler die Mindestanzahl von Zeichen in seinem Namen hat (was eine logische Überprüfung ist), wenn sein Vorname strukturell ungültig ist, indem er "null", leer oder mit Leerzeichen ist.

Strukturelle Validierungen haben die Aufgabe, die _erforderlichen_ Eigenschaften eines beliebigen Modells zu identifizieren, und während viele Technologien Validierungsannotationen, Plugins oder Bibliotheken zur globalen Durchsetzung von Datenvalidierungsregeln anbieten, entscheide ich mich dafür, die Validierung programmatisch und manuell durchzuführen, um mehr Kontrolle darüber zu haben, was erforderlich ist und was nicht in einer TDD-Mode.

Das Problem mit einigen der aktuellen Implementierungen von strukturellen und logischen Validierungen von Datenmodellen ist, dass sie sehr leicht unbemerkt geändert werden können, ohne dass Unit-Tests einen Alarm auslösen. Schauen Sie sich zum Beispiel dieses Beispiel an:

```csharp
public Student
{
	[Required]
	public string Name {get; set;}
}
```

Das obige Beispiel kann auf den ersten Blick aus technischer Sicht sehr verlockend sein. Alles was Sie tun müssen, ist Ihr Modellattribut mit einer magischen Annotation zu schmücken und schon werden Ihre Daten validiert.

Das Problem dabei ist, dass dieses Muster zwei oder mehr unterschiedliche Verantwortlichkeiten in ein und demselben Modell vereint. Modelle sollen lediglich eine Darstellung von Objekten in der Realität sein - nicht mehr und nicht weniger. Einige Ingenieure nennen sie anämische Modelle, die die Verantwortung jedes einzelnen Modells darauf konzentrieren, nur die Attribute des realen Objekts, das es zu simulieren versucht, ohne zusätzliche Details darzustellen.

Aber die kommentierten Modelle versuchen nun, Geschäftslogik in ihre Definitionen zu integrieren. Diese Geschäftslogik kann in allen Diensten, Brokern oder exponierten Komponenten, die sie verwenden, erforderlich sein oder auch nicht.

Strukturelle Validierungen von Modellen mögen wie zusätzliche Arbeit erscheinen, die durch magische Dekorationen vermieden werden kann. Aber wenn man versucht, von diesen Validierungen ein wenig abzuweichen, um mehr angepasste Validierungen zu erstellen, wird man ein neues Anti-Pattern sehen, wie z.B. benutzerdefinierte Annotationen, die durch Unit-Tests entdeckt werden können oder auch nicht.

Lassen Sie uns darüber sprechen, wie man eine strukturelle Validierungsroutine testet:

##### 2.1.3.1.2.0 Testen struktureller Validierungen

Da ich wirklich an die Wichtigkeit von TDD glaube, werde ich damit beginnen, die Implementierung von strukturellen Validierungen zu zeigen, indem ich zuerst einen fehlschlagenden Test dafür schreibe.

Nehmen wir an, wir haben ein Studentenmodell, mit den folgenden Details:

```csharp
public class Student
{
	public Guid Id {get; set;}
}
```

Wir wollen überprüfen, dass die Id des Schülers keine strukturell ungültige Id ist - wie z.B. eine leere `Guid` - daher würden wir einen Unit-Test in der folgenden Weise schreiben:

```csharp
[Fact]
public async void ShouldThrowValidationExceptionOnRegisterWhenIdIsInvalidAndLogItAsync()
{
	// given
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	inputStudent.Id = Guid.Empty;

	var invalidStudentException = new InvalidStudentException();

	invalidStudentException.AddData(
		key: nameof(Student.Id),
		value: "Id is required"
	);

	var expectedStudentValidationException =
		new StudentValidationException(invalidStudentException);

	// when
	ValueTask<Student> registerStudentTask =
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentValidationException actualStudentValidationException =
		await Assert.ThrowsAsync<StudentValidationException>(
			registerStudentTask.AsTask);

	// then
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException))),
				Times.Once);

	this.storageBrokerMock.Verify(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Never);

	this.dateTimeBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.storageBrokerMock.VerifyNoOtherCalls();
}
```

Im obigen Test haben wir ein zufälliges Studentenobjekt erstellt und dem Studenten `Id` den ungültigen Wert `Guid.Empty` zugewiesen.

Wenn die strukturelle Validierungslogik in unserem Basis-Dienst die Eigenschaft `Id` untersucht, sollte sie eine Ausnahme-Eigenschaft auslösen, die das Problem der Validierung in unserem Studentenmodell beschreibt. in diesem Fall werfen wir `InvalidStudentException`.

Die Ausnahme muss kurz das Was, Wo und Warum des Validierungsvorgangs beschreiben. In unserem Fall wäre das Was das auftretende Validierungsproblem, das Wo wäre der Dienst Student und das Warum wäre der Eigenschaftswert.

So würde eine `InvalidStudentException` aussehen:

```csharp
public class InvalidStudentException : Xeption
{
	public InvalidStudentException()
		:base ("Student ist ungueltig. Bitte beheben Sie die Fehler und versuchen Sie es erneut.")
	{ }
}
```

Der obige Unit-Test erfordert jedoch, dass unsere `InvalidStudentException` in eine generischere Ausnahme auf Systemebene verpackt wird, die `StudentValidationException` - diese Ausnahmen sind das, was ich als Outer-Exceptions bezeichne, sie kapseln alle verschiedenen Situationen von Validierungen unabhängig von ihrer Kategorie und kommunizieren den Fehler an vorgelagerte Dienste oder Controller, so dass diese den richtigen Fehlercode für den Verbraucher dieser Dienste zuordnen können.

Unsere `StudentValidationException` würde wie folgt implementiert werden:

```csharp
public class StudentValidationException : Exception
{
	public StudentValidationException(Exception innerException)
		: base("Es ist ein StudentValidationFehler aufgetreten, bitte überprüfen Sie Ihre Eingaben und versuchen Sie es dann erneut.", innerException) { }
}
```

Die Meldung in der obigen äußeren Validierung weist darauf hin, dass das Problem in der Eingabe liegt, und fordert daher den Einsender auf, es noch einmal zu versuchen, da von Seiten des Systems keine Maßnahmen zur Anpassung erforderlich sind.

##### 2.1.3.1.2.1 Strukturelle Validierungen implementieren

Betrachten wir nun die andere Seite des Validierungsprozesses, nämlich die Implementierung.
Strukturelle Validierungen kommen immer vor allen anderen Arten von Validierungen. Das liegt einfach daran, dass strukturelle Validierungen aus Sicht der Ausführung und der asymptotischen Zeit am billigsten sind.
Es ist zum Beispiel viel billiger, eine "ID" strukturell zu validieren, als einen API-Aufruf zu senden, um genau dieselbe Antwort zu erhalten, zuzüglich der Kosten für die Latenzzeit. Dies alles summiert sich, wenn mehrere Millionen Anfragen pro Sekunde eingehen.
Strukturelle und logische Validierungen werden im Allgemeinen in einer eigenen partiellen Klasse ausgeführt. Wenn unser Dienst beispielsweise "StudentService.cs" heißt, sollte eine neue Datei mit dem Namen "StudentService.Validations.cs" erstellt werden, um die Validierungsregeln zu kapseln und visuell zu abstrahieren, um sicherzustellen, dass saubere Daten ein- und ausgehen.
So würde eine Id-Validierung aussehen:

###### StudentService.Validations.cs

```csharp

private void ValidateStudent(Student student)
{
	Validate((Rule: IsInvalid(student.Id), Parameter: nameof(Student.Id)));
}

private static dynamic IsInvalid(Guid id) => new
{
	Condition = id == Guid.Empty,
	Message = "Id is required"
};

private void Validate(params (dynamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new InvalidStudentException();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertData(parameter, rule.Message);
		}
	}

	invalidStudentException.ThrowIfContainsErrors();
}
```

Wir haben eine Methode zur Validierung des gesamten Studentenobjekts implementiert, mit einer Zusammenstellung aller Regeln, die wir zur strukturellen und logischen Validierung des Studenten-Eingabeobjekts aufstellen müssen. Das Wichtigste an dem obigen Codeschnipsel ist die Kapselung aller feineren Details, die weiter vom Hauptziel einer bestimmten Methode entfernt sind.

Aus diesem Grund haben wir uns entschieden, eine private statische Methode `IsInvalid` zu implementieren, um die Details zu abstrahieren, die bestimmen, ob eine Eigenschaft vom Typ `Guid` ungültig ist oder nicht. Im weiteren Verlauf der Implementierung werden wir mehrere Überladungen der gleichen Methode implementieren müssen, um andere Wertetypen strukturell und logisch zu überprüfen.

Der Zweck der Methode `ValidateStudent` ist es, einfach die Regeln aufzustellen und eine Aktion durchzuführen, indem eine Ausnahme geworfen wird, wenn eine dieser Regeln verletzt wird. Es besteht immer die Möglichkeit, die Verletzungsfehler zusammenzufassen, anstatt beim ersten Anzeichen eines strukturellen oder logischen Validierungsproblems zu früh zu reagieren.

Mit der obigen Implementierung müssen wir nun diese Methode aufrufen, um unsere Eingaben strukturell und logisch zu validieren. Rufen wir diese Methode in unserer Methode `RegisterStudentAsync` wie folgt auf:

###### StudentService.cs

```csharp
public ValueTask<Student> RegisterStudentAsync(Student student) =>
TryCatch(async () =>
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

Auf den ersten Blick werden Sie feststellen, dass unsere Methode hier nicht unbedingt irgendeine Art von Ausnahmen auf der Logikebene behandelt. Das liegt daran, dass das ganze Ausnahmegeräusch auch in einer Methode namens `TryCatch` abstrahiert wird.

TryCatch" ist ein Konzept, das ich erfunden habe, um es Ingenieuren zu ermöglichen, sich auf das zu konzentrieren, was am wichtigsten ist, je nachdem, welchen Aspekt des Dienstes sie betrachten, ohne irgendwelche Abkürzungen bei der Ausnahmebehandlung nehmen zu müssen, um den Code ein wenig lesbarer zu machen.

Die `TryCatch`-Methoden befinden sich im Allgemeinen in einer anderen partiellen Klasse und einer völlig neuen Datei namens `StudentService.Exceptions.cs`, in der die gesamte Ausnahmeverarbeitung und Fehlerberichterstattung stattfindet, wie ich im folgenden Beispiel zeigen werde.

Werfen wir einen Blick darauf, wie eine `TryCatch`-Methode aussieht:

###### StudentService.Exceptions.cs

```csharp
private delegate ValueTask<Student> ReturningStudentFunction();

private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	catch (InvalidStudentException invalidStudentInputException)
	{
		throw CreateAndLogValidationException(invalidStudentInputException);
	}
}

private StudentValidationException CreateAndLogValidationException(Exception exception)
{
	var studentValidationException = new StudentValidationException(exception);
	this.loggingBroker.LogError(studentValidationException);

	return studentValidationException;
}
```

Das Muster zur Rauschunterdrückung von Ausnahmen "TryCatch" nimmt jede Funktion, die einen bestimmten Typ zurückgibt, als Delegaten auf und behandelt alle ausgelösten Ausnahmen von dieser Funktion oder ihren Abhängigkeiten.

Die Hauptaufgabe einer `TryCatch'-Funktion ist es, innere Ausnahmen eines Dienstes mit äußeren Ausnahmen zu umhüllen, um die Reaktion externer Verbraucher dieses Dienstes auf eine der drei Kategorien zu erleichtern, nämlich Dienstausnahmen, Validierungsausnahmen und Abhängigkeitsausnahmen.

In einer `TryCatch`-Methode können wir beliebig viele innere und externe Ausnahmen hinzufügen und sie in lokale Ausnahmen für vorgelagerte Dienste abbilden, die keine starke Abhängigkeit von bestimmten Bibliotheken oder externen Ressourcenmodellen haben, worüber wir im Detail sprechen werden, wenn wir zur Verantwortung für die Abbildung von Broker-Nachbarn (Basis) Diensten übergehen.

#### 2.1.3.1.3 Logische Überprüfungen

Logische Validierungen stehen in der Rangfolge der strukturellen Validierungen an zweiter Stelle. Ihre Hauptaufgabe besteht definitionsgemäß darin, logisch zu überprüfen, ob ein strukturell gültiges Datenelement auch logisch gültig ist.
So könnte beispielsweise das Geburtsdatum eines Studenten strukturell gültig sein, wenn es den Wert "1.1.1800" hat, aber logisch gesehen ist ein Student, der über 200 Jahre alt ist, ein Ding der Unmöglichkeit.

Die gebräuchlichsten logischen Überprüfungen sind Überprüfungen für Prüffelder wie "Erstellt von" und "Aktualisiert von" - es ist logisch unmöglich, dass ein neuer Datensatz mit zwei verschiedenen Werten für die Autoren dieses neuen Datensatzes eingefügt werden kann - einfach deshalb, weil Daten immer nur von einer Person gleichzeitig eingefügt werden können.

Lassen Sie uns darüber sprechen, wie wir logische Überprüfungen testen und implementieren können:

##### 2.1.3.1.3.0 Testen logischer Validierungen

Im üblichen Fall des Testens logischer Überprüfungen für Audit-Felder wollen wir eine Validierungsausnahme auslösen, die besagt, dass der Wert `UpdatedBy` ungültig ist, weil er nicht mit dem Feld `CreatedBy` übereinstimmt.

Nehmen wir an, unser Studentenmodell sieht wie folgt aus:

```csharp
public class Student {
	Guid CreatedBy {get; set;}
	Guid UpdatedBy {get; set;}
}
```

Unser Test, um diese Werte logisch zu validieren, würde wie folgt aussehen:

```csharp
[Fact]
public async Task ShouldThrowValidationExceptionOnRegisterIfUpdatedByNotSameAsCreatedByAndLogItAsync()
{
	// gegeben
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	inputStudent.UpdatedBy = Guid.NewGuid();

	var invalidStudentException = new InvalidStudentException();

	invalidStudentException.AddData(
		key: nameof(Student.UpdatedBy),
		value: $"Id ist nicht dasselbe wie {nameof(Student.CreatedBy)}.");

	var expectedStudentValidationException =
		new StudentValidationException(invalidStudentException);

	// wenn
	ValueTask<Student> registerStudentTask =
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentValidationException actualStudentValidationException =
		await Assert.ThrowsAsync<StudentValidationException>(
			registerStudentTask.AsTask);

	// dann
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException))),
				Times.Once);

	this.storageBrokerMock.Verify(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Never);

	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.dateTimeBrokerMock.VerifyNoOtherCalls();
	this.storageBrokerMock.VerifyNoOtherCalls(); this.storageBrokerMock.VerifyNoOtherCalls();
}
```

Im obigen Test haben wir den Wert des Feldes `UpdatedBy` geändert, um sicherzustellen, dass er sich vollständig vom Feld `CreatedBy` unterscheidet - jetzt erwarten wir, dass eine `InvalidStudentException` mit dem `CreatedBy` der Grund für das Auftreten dieser Validierungsausnahme ist.

Lassen Sie uns fortfahren und eine Implementierung für diesen fehlgeschlagenen Test schreiben.

##### 2.1.3.1.3.1 Implementierung von logischen Überprüfungen

Genau wie im Abschnitt über die strukturellen Validierungen fügen wir weitere Regeln zu unserem Validierungs-"Switch Case" wie folgt hinzu:

###### StudentService.Validations.cs

```csharp
private void ValidateStudent(Student student)
{
	Validate(
		(Rule: IsNotSame(
			firstId: student.UpdatedBy,
			secondId: student.CreatedBy,
			secondIdName: nameof(student.CreatedBy)),
		Parameter: nameof(Student.UpdatedBy))
	);
}

private static dynamic IsNotSame(
	Guid firstId,
	Guid secondId,
	string secondIdName) => new
	{
		Condition = firstId != secondId,
		Message = $"Id is not the same as {secondIdName}."
	};

private void Validate(params (dyanamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new Exception();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertData(
				key: parameter,
				value: rule.Message);
		}
	}
}
```

Alles andere in `StudentService.cs` und `StudentService.Exceptions.cs` bleibt genau so, wie wir es oben bei den strukturellen Überprüfungen gemacht haben.

Logische Validierungsausnahmen sind, wie alle anderen Ausnahmen, die auftreten können, normalerweise unkritisch. Es hängt jedoch alles von Ihrem Geschäftsfall ab, ob eine bestimmte logische, strukturelle oder sogar eine Abhängigkeitsüberprüfung kritisch ist oder nicht. In diesem Fall müssen Sie möglicherweise eine spezielle Klasse von Ausnahmen erstellen, etwa `InvalidStudentCriticalException`, und diese entsprechend protokollieren.

#### 2.1.3.1.4 Externe Überprüfungen

Die letzte Art von Validierungen, die normalerweise von Basis-Diensten durchgeführt werden, sind externe Validierungen. Ich definiere externe Validierungen als jede Form der Validierung, die den Aufruf einer externen Ressource erfordert, um zu überprüfen, ob ein Basisdienst mit der Verarbeitung eingehender Daten fortfahren oder mit einer Ausnahme anhalten sollte.

Ein gutes Beispiel für die Validierung von Abhängigkeiten ist der Aufruf eines Brokers zum Abrufen einer bestimmten Entität anhand ihrer ID. Wenn die zurückgegebene Entität nicht gefunden wird oder der API-Broker einen `NotFound`-Fehler zurückgibt, muss der Basisdienst diesen Fehler in eine `ValidationException` verpacken und alle folgenden Prozesse anhalten.

Externe Validierungsausnahmen können auftreten, wenn der zurückgegebene Wert nicht den Erwartungen entspricht, z. B. eine leere Liste, die von einem API-Aufruf zurückgegeben wird, wenn versucht wird, einen neuen Trainer einer Mannschaft einzufügen - wenn es keine Mannschaftsmitglieder gibt, kann es z. B. auch keinen Trainer geben. Der Basis-Dienst muss in diesem Fall eine lokale Ausnahme auslösen, um das Problem zu erklären, etwa `NoTeamMembersFoundException` oder etwas in der Art.

Lassen Sie uns einen fehlschlagenden Test für ein externes Validierungsbeispiel schreiben:

##### 2.1.3.1.4.0 Testen externer Validierungen

Nehmen wir an, wir versuchen, einen Schüler mit einer `Id` abzurufen, die mit keinem Datensatz in der Datenbank übereinstimmt. So würden wir vorgehen, um dieses Szenario zu testen. Als erstes definieren wir ein `NotFoundStudentException` Modell wie folgt:

```csharp
using Xeption;

public class NotFoundStudentException : Xeption
{
	public NotFoundStudentException(Guid id)
		: base (message: $"Couldn't find a student with id: {id}.")
	{}
}
```

Das obige Modell ist der Lokalisierungsaspekt der Behandlung des Problems. Lassen Sie uns nun einen fehlschlagenden Test wie folgt schreiben:

```csharp
public async Task ShouldThrowValidationExceptionOnRetrieveByIdIfStudentNotFoundAndLogItAsync()
{
	// gegeben
	Guid randomStudentId = Guid.NewGuid();
	Guid inputStudentId = randomStudentId;
	Student noStudent = null;

	var notFoundStudentException =
		new NotFoundStudentException(inputStudentId);

	var expectedStudentValidationException =
		new StudentValidationException(notFoundStudentException);

	this.storageBrokerMock.Setup(broker =>
		broker.SelectStudentByIdAsync(inputStudentId))
			.ReturnsAsync(noStudent);

	// wenn
	ValueTask<Student> retrieveStudentByIdTask =
		this.studentService.RetrieveStudentByIdAsync(inputStudentId);

	StudentValidationException actualStudentValidationException =
		await Assert.ThrowsAsync<StudentValidationException>(
			retrieveStudentByIdTask.AsTask);

	// dann
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.storageBrokerMock.Verify(broker =>
		broker.SelectStudentByIdAsync(inputStudentId),
			Times.Once);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException))),
				Times.Once);

	this.storageBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.dateTimeBrokerMock.VerifyNotOtherCalls();
}
```

Der obige Test erfordert, dass wir eine lokalisierte Ausnahme wie in `NotFoundStudentException` auslösen, wenn der Speicher-Broker keine Werte für die angegebene `studentId` zurückgibt, und diese dann in `StudentValidationException` verpacken oder kategorisieren.

Wir haben uns dafür entschieden, die lokalisierte Ausnahme in eine Validierungsausnahme und nicht in eine Ausnahme zur Validierung von Abhängigkeiten zu verpacken, weil die Auslösung des Fehlers von unserem Dienst und nicht von der externen Ressource ausging. Wäre die externe Ressource die Quelle des Fehlers, müssten wir diesen als `DependencyValidationException` kategorisieren, was wir in Kürze besprechen werden.

Kommen wir nun zum Implementierungsteil dieses Abschnitts, um unseren Test erfolgreich zu machen.

##### 2.1.3.1.4.1 Externe Validierungen implementieren

Um eine externe Validierung zu implementieren, müssen wir alle verschiedenen Aspekte unseres Dienstes berühren. Die Kernlogik, die Validierung und die Ausnahmeverarbeitung sind wie folgt.

Als erstes wollen wir eine Validierungsfunktion erstellen, die eine `NotFoundStudentException` auslöst, wenn der übergebene Parameter Null ist.

###### StudentService.Validations.cs

```csharp
private static void VerifyStudentExists(Student maybeStudent, Guid studentId)
{
	if (maybeStudent is null)
	{
		throw new NotFoundStudentException(studentId);
	}
}
```

Diese Implementierung sorgt dafür, dass ein Problem erkannt und eine lokale Ausnahme `NotFoundStudentException` ausgegeben wird. Kommen wir nun zu dem Aspekt der Ausnahmeverarbeitung unseres Dienstes.

###### StudentService.Exceptions.cs

```csharp
private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	..
	catch (NotFoundStudentException notFoundStudentException)
	{
		throw CreateAndLogValidationException(notFoundStudentException);
	}
}

private StudentValidationException CreateAndLogValidationException(Exception exception)
{
	var studentValidationException = new StudentValidationException(exception);
	this.loggingBroker.LogError(studentValidationException);

	return studentValidationException;
}
```

Die obige Implementierung kümmert sich um die Kategorisierung einer `NotFoundStudentException` in eine `StudentValidationException`. Der letzte Teil besteht darin, die Teile wie folgt zusammenzusetzen.

###### StudentService.cs

```csharp
public ValueTask<Student> RetrieveStudentByIdAsync(Guid studentId) =>
TryCatch(async () =>
{
	ValidateStudentId(studentId);

	Student maybeStudent =
		await this.storageBroker.SelectStudentByIdAsync(studentId);

	ValidateStudentExists(maybeStudent, studentId);

	return maybeStudent;
});
```

Die obige Implementierung stellt sicher, dass die ID gültig ist, aber noch wichtiger ist, dass alles, was der `storageBroker` zurückgibt, daraufhin überprüft wird, ob es ein Objekt oder `null` ist. Dann wird die Ausnahme ausgegeben.

Es gibt Situationen, in denen der Versuch, eine Entität abzurufen und dann herauszufinden, dass sie nicht existiert, nicht unbedingt fehlerhaft ist. Hier kommen die verarbeitenden Dienste ins Spiel, die eine übergeordnete Geschäftslogik nutzen, um mit diesem komplexeren Szenario umzugehen.

#### 2.1.3.1.5 Abhängigkeitsvalidierungen

Ausnahmen bei der Abhängigkeitsvalidierung können auftreten, weil Sie eine externe Ressource aufgerufen haben und diese einen Fehler oder einen Wert zurückgegeben hat, der eine Fehlerauslösung rechtfertigt. Zum Beispiel könnte ein API-Aufruf einen "404"-Code zurückgeben, was als Ausnahme interpretiert wird, wenn die Eingabe einem existierenden Objekt entsprechen sollte.

Ein häufigeres Beispiel ist, wenn eine bestimmte Eingabeentität dieselbe ID wie eine bestehende Entität im System verwendet. In einer relationalen Datenbank würde eine Duplikatschlüssel-Ausnahme ausgelöst werden. In einem RESTful-API-Szenario wird durch die programmatische Anwendung desselben Konzepts dasselbe Ziel für API-Validierungen erreicht, vorausgesetzt, die Granularität des aufgerufenen Systems schwächt die referenzielle Integrität der gesamten Systemdaten.

Es gibt Situationen, in denen die fehlerhafte Antwort auf eine andere Weise als durch Ausnahmen ausgedrückt werden kann, aber wir werden dieses Thema in einem fortgeschritteneren Kapitel dieses Standards behandeln.

Lassen Sie uns einen fehlgeschlagenen Test schreiben, um zu überprüfen, ob wir eine `DependencyValidationException` auslösen, wenn das Modell `Student` bereits im Speicher vorhanden ist und der Speicher-Broker eine `DuplicateKeyException` als natives Ergebnis der Operation auslöst.

##### 2.1.3.1.5.0 Testen von Abhängigkeitsvalidierungen

Nehmen wir an, unser Studentenmodell verwendet eine `Id` mit dem Typ `Guid` wie folgt:

```csharp
public class Student
{
	public Guid Id {get; set;}
	public string Name {get; set;}
}
```

unser Unit-Test, um zu überprüfen, ob eine "DependencyValidation"-Ausnahme in einer "DuplicateKey"-Situation ausgelöst wird, würde wie folgt aussehen:

```csharp
[Fact]
public async void ShouldThrowDependencyValidationExceptionOnRegisterIfStudentAlreadyExistsAndLogItAsync()
{
	// gegeben
	Student someStudent = CreateRandomStudent();
	string someMessage = GetRandomMessage();
	var duplicateKeyException = new DuplicateKeyException(exceptionMessage);

	var alreadyExistsStudentException =
		new AlreadyExistsStudentException(duplicateKeyException);

	var expectedStudentDependencyValidationException =
		new StudentDependencyValidationException(alreadyExistsStudentException);

	this.storageBrokerMock.Setup(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()))
			.ThrowsAsync(duplicateKeyException);

	// wenn
	ValueTask<Student> registerStudentTask =
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentDependencyValidationException actualStudentDependencyValidationException =
		await Assert.ThrowsAsync<StudentDependencyValidationException>(
			registerStudentTask.AsTask);

	// dann
	actualStudentDependencyValidationException.Should().BeEquivalentTo(
		expectedStudentDependencyValidationException);

	this.storageBrokerMock.Verify(broker =>
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Once);

	this.loggingBrokerMock.Verify(broker =>
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentDependencyValidationException))),
				Times.Once);

	this.storageBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
}
```

Im obigen Test validieren wir, dass wir eine native `DuplicateKeyException` in ein lokales Modell verpacken, das auf den spezifischen Modellfall zugeschnitten ist, der in unserem Beispiel die `AlreadyExistsStudentException` ist. Dann verpacken wir das wiederum mit einem generischen Kategorie-Ausnahme-Modell, das die `StudentDependencyValidationException` ist.

Es gibt eine Reihe von Regeln, die den Aufbau von Abhängigkeitsüberprüfungen regeln, die wie folgt lauten:

- Regel 1: Wenn eine Abhängigkeitsvalidierung eine andere Abhängigkeitsvalidierung von einem nachgelagerten Dienst bearbeitet, dann sollte die innere Ausnahme der nachgelagerten Ausnahme für die Abhängigkeitsvalidierung auf der aktuellen Ebene die gleiche sein.

Mit anderen Worten, wenn ein `StudentService` eine `StudentDependencyValidationException` an einen vorgelagerten Dienst wie den `StudentProcessingService` wirft - dann ist es wichtig, dass die `StudentProcessingDependencyValidationException` die gleiche innere Ausnahme enthält wie die `StudentDependencyValidationException`. Das liegt daran, dass, sobald diese Ausnahmen in Exposition-Komponenten, wie z.B. API-Controller oder UI-Komponenten, gemappt werden, die ursprüngliche Validierungsnachricht sich durch das System ausbreiten und dem Endbenutzer präsentiert werden muss, egal woher sie stammt.

Außerdem garantiert die Beibehaltung der ursprünglichen inneren Ausnahme die Möglichkeit, verschiedene Fehlermeldungen über API-Endpunkte zu kommunizieren. So kann zum Beispiel `AlreadyExistsStudentException` als `Conflict` oder `409` auf API-Controller-Ebene kommuniziert werden - dies unterscheidet sich von einer anderen Abhängigkeitsvalidierungsausnahme wie `InvalidStudentReferenceException`, die als `FailedDependency`-Fehler oder `424` kommuniziert werden würde.

- Regel 2: Wenn eine Abhängigkeitsvalidierungsausnahme eine Nicht-Abhängigkeitsvalidierungsausnahme behandelt, sollte sie diese Ausnahme als ihre innere Ausnahme nehmen und nichts anderes.

Diese Regeln stellen sicher, dass nur die lokale Validierungsausnahme weitergegeben wird und nicht die native Ausnahme von einem Speichersystem oder einer API oder einer anderen externen Abhängigkeit.

Das ist der Fall, den wir hier mit unserer `AlreadyExistsStudentException` und ihrer `StudentDependencyValidationException` haben - die systemeigene Ausnahme ist komplett versteckt, und die Zuordnung dieser systemeigenen Ausnahme und ihrer inneren Nachricht ist das, was dem Endbenutzer mitgeteilt wird. Dies gibt den Ingenieuren die Möglichkeit zu kontrollieren, was vom anderen Ende ihres Systems aus kommuniziert wird, anstatt die native Nachricht (die sich ändern kann) an die Endbenutzer weiterzugeben.

##### 2.1.3.0.5.1 Implementierung von Abhängigkeitsvalidierungen

Je nachdem, woher der Validierungsfehler stammt, kann die Implementierung von Abhängigkeitsvalidierungen eine Geschäftslogik enthalten oder nicht. Wie bereits erwähnt, müssen wir, wenn der Fehler von der externen Ressource stammt (was hier der Fall ist), diesen Fehler nur in eine lokale Ausnahme verpacken und ihn dann mit einer externen Ausnahme unter der Abhängigkeitsvalidierung kategorisieren.

Um sicherzustellen, dass der oben erwähnte Test bestanden wird, benötigen wir einige Modelle.
Für die `AlreadyExistsStudentException` würde die Implementierung wie folgt aussehen:

```csharp
public class AlreadyExistsStudentException : Exception
{
	public AlreadyExistsStudentException(Exception innerException)
		: base($"Student with the same Id already exists", innerException){ }
}
```

Wir brauchen auch die `StudentDependencyValidationException`, die wie folgt aussehen sollte:

```csharp
public class StudentDependencyValidationException : Exception
{
	public StudentDependencyValidationException(Exception innerException)
		: base($"Student dependency validation error occurred, please try again.", innerException){ }
}

```

Kommen wir nun zur Implementierung und beginnen wir mit der Logik für die Ausnahmeverarbeitung:

###### StudentService.Exceptions.cs

```csharp
private delegate ValueTask<Student> ReturningStudentFunction();

private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	...
	catch (DuplicateKeyException duplicateKeyException)
	{
		var alreadyExistsStudentException = new AlreadyExistsStudentException(duplicateKeyException);
		throw CreateAndLogDependencyValidationException(alreadyExistsStudentException);
	}
}

...

private StudentDependencyValidationException CreateAndLogDependencyValidationException(Exception exception)
{
	var studentDependencyValidationException = new StudentDependencyValidationException(exception);
	this.loggingBroker.LogError(studentDependencyValidationException);

	return studentDependencyValidationException;
}
```

Wir haben die lokale innere Ausnahme im catch-Block unseres Ausnahmebehandlungsprozesses erstellt, um die Wiederverwendbarkeit unserer Ausnahmemethode zur Abhängigkeitsvalidierung für andere Situationen zu ermöglichen, die dieselbe Ebene externer Ausnahmen erfordern.

Der Verweis auf die Methode `TryCatch` in der Datei `StudentService.cs` bleibt ansonsten unverändert.

### 2.1.3.2 Mapping

Die zweite Aufgabe eines Basis Dienstes ist es, die Rolle eines Mappers zwischen lokalen Modellen und nicht-lokalen Modellen zu übernehmen. Wenn Sie beispielsweise einen E-Mail-Dienst nutzen, der seine eigenen SDKs für die Integration bereitstellt, und Ihre Broker bereits die APIs für diesen Dienst verpacken und bereitstellen, muss Ihr Basisdienst die Ein- und Ausgaben der Broker-Methoden auf lokale Modelle abbilden. Die gleiche Situation und häufiger zwischen nativen nicht-lokalen Ausnahmen, wie die, die wir oben mit der Situation der Abhängigkeitsvalidierung erwähnt haben, gilt der gleiche Aspekt nur für Abhängigkeitsfehler oder Dienstfehler, wie wir in Kürze besprechen werden.

#### 2.1.3.2.0 Nicht-lokale Modelle

Diese Dienste können lokal in der Gesamtarchitektur oder dem verteilten System sein, in dem die Anwendung läuft, oder es kann sich um einen Drittanbieter handeln, wie z. B. einige der beliebten E-Mail-Dienste.
Die Anbieter externer Dienste investieren viel Mühe in die Entwicklung flüssiger APIs, SDKs und Bibliotheken in allen gängigen Programmiersprachen, um den Ingenieuren die Integration ihrer Anwendungen mit diesem Drittanbieterdienst zu erleichtern. Nehmen wir zum Beispiel an, ein Drittanbieter von E-Mail-Diensten bietet über seine SDKs die folgende API an:

```csharp
öffentliche Schnittstelle IEmailServiceProvider
{
	ValueTask<EmailMessage> SendEmailAsync(EmailMessage message);
}
```

Nehmen wir an, dass das Modell `EmailMessage` ein natives Modell ist, das mit dem SDK des E-Mail-Dienstanbieters geliefert wird. Ihre Broker könnten einen Wrapper um diese API herum anbieten, indem sie einen Vertrag erstellen, um die _Funktionalität_ zu abstrahieren, aber sie können nicht viel mit den nativen Modellen machen, die in diese Funktionalität hineingereicht oder aus ihr zurückgegeben werden. Daher würde unsere Broker-Schnittstelle ungefähr so aussehen:

```csharp
öffentliche Schnittstelle IEmailBroker
{
	ValueTask<EmailMessage> SendEmailMessageAsync(EmailMessage message);
}
```

Dann würde die Implementierung etwa so aussehen:

```csharp
public class EmailBroker : IEmailBroker
{
	public async ValueTask<EmailMessage> SendEmailMessageAsync(EmailMessage message) =>
		await this.emailServiceProvider.SendEmailAsync(message);
}
```

Wie bereits erwähnt, haben die Broker hier ihren Teil der Abstraktion geleistet, indem sie die eigentliche Implementierung und die Abhängigkeiten des nativen `EmailServiceProvider` von unseren Basis-Services weggeschoben haben. Aber das ist nur 50% der Aufgabe, die Abstraktion ist noch nicht ganz vollständig, bis es keine Spuren des nativen `EmailMessage`-Modells mehr gibt. An dieser Stelle kommen die Basis-Dienste ins Spiel, die eine testgesteuerte Zuordnung zwischen den nativen nicht-lokalen Modellen und den lokalen Modellen Ihrer Anwendung vornehmen. Daher ist es durchaus möglich, dass eine Zuordnungsfunktion in einem Basis-Dienst das native Modell vom Rest Ihrer Geschäftsschichtdienste abstrahiert.

Ihr Basis Dienst muss dann ein neues lokales Modell unterstützen, nennen wir es `Email`. Die Eigenschaft Ihres lokalen Modells kann mit dem externen Modell `EmailMessage` identisch sein - insbesondere auf der Ebene der primitiven Datentypen. Aber das neue Modell wäre der einzige Vertrag zwischen Ihrer reinen Geschäftslogikschicht (Verarbeitungs-, Orchestrierungs-, Koordinierungs- und Verwaltungsdienste) und Ihrer hybriden Logikschicht wie den Basisdiensten. Hier ein Codeschnipsel für diesen Vorgang:

```csharp
public async ValueTask<Email> SendEmailMessageAsync(Email email)
{
	EmailMessage inputEmailMessage = MapToEmailMessage(email);
	EmailMessage sentEmailMessage = await this.emailBroker.SendEmailMessageAsync(inputEmailMessage);

	return MapToEmail(sentEmailMessage);
}

```

Je nachdem, ob die zurückgegebene Nachricht einen Status hat oder ob man die Eingabenachricht als Zeichen für eine erfolgreiche Operation zurückgeben möchte, sind in meinem Standard beide Vorgehensweisen gültig. Das obige Codeschnipsel ist ein ideales Szenario, in dem Ihr Code versucht, sowohl dem übergebenen Wert als auch dem zurückgegebenen Wert mit allen notwendigen Zuordnungen treu zu bleiben.

#### 2.1.3.2.1 Ausnahmen Zuordnungen

Genau wie die nicht-lokalen Modelle müssen Ausnahmen, die entweder von der externen API wie den EntityFramework-Modellen `DbUpdateException` oder anderen erzeugt werden, auf lokale Ausnahmemodelle abgebildet werden.
Die frühzeitige Behandlung dieser nicht-lokalen Ausnahmen vor dem Eintritt in die Komponenten der reinen Geschäftsschicht verhindert eine potenzielle enge Kopplung oder Abhängigkeit von einem externen Modell.
Wenn wir z.B. versuchen, eine "UserNotFoundException" zu behandeln, die z.B. bei der Verwendung von Microsoft Graph ausgelöst wird, möchten wir nicht unbedingt die gesamte Prozedur beenden, sondern vielleicht einen Benutzer in einem anderen Speicher für die zukünftige Graph-Submission-Verarbeitung hinzufügen.
Externe APIs sollten keinen Einfluss darauf haben, ob ein interner Vorgang angehalten werden sollte oder nicht. Die Behandlung von Ausnahmen auf der Basis-Schicht ist daher die Garantie dafür, dass sich dieser Einfluss auf die Grenzen des Bereichs für die Behandlung externer Ressourcen in unserer Anwendung beschränkt und keinerlei Auswirkungen auf unsere Kerngeschäftsprozesse hat.
Die folgende Abbildung soll das Bild aus dieser Perspektive etwas klarer zeichnen:
<br />

<p align=center>
<img src="https://user-images.githubusercontent.com/1453985/112714067-b7366a00-8e95-11eb-9bb7-a5a047640f4a.png" />
</p>
<br />

Hier sind einige gängige Szenarien für die Abbildung von nativen oder inneren lokalen Ausnahmen auf äußere Ausnahmen:

| Exception | Wrap Inner Exception With | Wrap With | Log Level |
| ------------------------------------- | -------------------------------- | ------------------------------------ | --------- |
| NullStudentException                  | -                                | StudentValidationException           | Error     |
| InvalidStudentException               | -                                | StudentValidationException           | Error     |
| SqlException                          | FailedStudentStorageException    | StudentDependencyException           | Critical  |
| HttpResponseUrlNotFoundException      | FailedStudentApiException        | StudentDependencyException           | Critical  |
| HttpResponseUnauthorizedException     | FailedStudentApiException        | StudentDependencyException           | Critical  |
| NotFoundStudentException              | -                                | StudentValidationException           | Error     |
| HttpResponseNotFoundException         | NotFoundStudentException         | StudentDependencyValidationException | Error     |
| DuplicateKeyException                 | AlreadyExistsStudentException    | StudentDependencyValidationException | Error     |
| HttpResponseConflictException         | AlreadyExistsStudentException    | StudentDependencyValidationException | Error     |
| ForeignKeyConstraintConflictException | InvalidStudentReferenceException | StudentDependencyValidationException | Error     |
| DbUpdateConcurrencyException          | LockedStudentException           | StudentDependencyValidationException | Error     |
| DbUpdateException                     | FailedStudentStorageException    | StudentDependencyException           | Error     |
| HttpResponseException                 | FailedStudentApiException        | StudentDependencyException           | Error     |
| Exception                             | FailedStudentServiceException    | StudentServiceException              | Error     |

[*] [Standardisierung von Validierungen & Ausnahmen](https://www.youtube.com/watch?v=Wtpxb7yPQP0)

[*] [Testgesteuerte nicht-kreislaufbrechende Validierungen](https://www.youtube.com/watch?v=guJPrIQ0kJk)
