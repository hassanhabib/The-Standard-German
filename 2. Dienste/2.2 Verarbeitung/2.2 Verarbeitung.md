# 2.2 Verarbeitende Dienste (übergeordnete Geschäftslogik)

## 2.2.0 Einleitung

Verarbeitungsdienste sind die Schicht, in der eine höhere Ordnung der Geschäftslogik implementiert wird. Sie können zwei primitive Funktionen aus ihrem entsprechenden Basis-Dienst kombinieren (oder orchestrieren), um eine neuere Funktionalität einzuführen. Sie können auch eine primitive Funktion aufrufen und das Ergebnis mit ein wenig zusätzlicher Geschäftslogik verändern. Und manchmal dienen Verarbeitungsdienste als Durchreichefunktion, um die Gesamtarchitektur auszugleichen.

Verarbeitungsdienste sind optional und hängen von Ihren geschäftlichen Anforderungen ab - in einer einfachen CRUD-Operationen-API werden Verarbeitungsdienste und alle anderen Kategorien von Diensten über diesen Punkt hinaus nicht mehr existieren, da an diesem Punkt keine Notwendigkeit für eine höhere Ordnung der Geschäftslogik besteht.

Hier ist ein Beispiel dafür, wie eine Verarbeitungsdienstfunktion aussehen würde:

```csharp
public ValueTask<Student> UpsertStudentAsync(Student student) =>
TryCatch(async () =>
{
    ValidateStudent(student);

    IQueryable<Student> allStudents =
        this.studentService.RetrieveAllStudents();

    bool studentExists = allStudents.Any(abgerufenerStudent =>
        abgerufenerSchüler.Id == Schüler.Id);

    return studentExists switch {
        false => await this.studentService.RegisterStudentAsync(student),
        _ => await this.studentService.ModifyStudentAsync(student.Id)
    };
});
```

Durch die Verarbeitungsdienste sind die Basis-Dienste nichts anderes als eine Validierungsschicht über den bestehenden primitiven Operationen. Das bedeutet, dass die Funktionen der Verarbeitungsdienste über die primitiven Operationen hinausgehen und sich nur mit lokalen Modellen befassen, wie wir in den nächsten Abschnitten diskutieren werden.

## 2.2.1 Auf der Karte

Sie dürfen keine Entity- oder Business-Broker aufrufen, wohl aber Utility-Broker wie Logging-Broker, Time-Broker und alle anderen Broker, die unterstützende Funktionalität bieten und nicht spezifisch für eine bestimmte Geschäftslogik sind. Die folgende Abbildung zeigt, wo sich die verarbeitenden Dienste auf der Karte unserer Architektur befinden:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/111928442-d9cd1b00-8a70-11eb-82c8-83399c98c87d.png" />
    </p>
<br />

Auf der rechten Seite eines Verarbeitungsdienstes befinden sich alle nichtlokalen Modelle und Funktionen, sei es durch die Broker oder die Modelle, die der Basisdienst in lokale Modelle abzubilden versucht.
Auf der linken Seite der Verarbeitungsdienste befinden sich die rein lokale Funktionalität, Modelle und Architektur. Ausgehend von den verarbeitenden Diensten selbst, sollte es keine Spur von nativen oder nicht-lokalen Modellen im System geben.

## 2.2.2 Merkmale

Verarbeitungsdienste sind im Allgemeinen Kombinatoren mehrerer Funktionen auf primitiver Ebene, um eine Geschäftslogik höherer Ordnung zu erzeugen, aber sie haben noch viel mehr Eigenschaften, auf die wir hier eingehen wollen.

### 2.2.2.0 Sprache

Die Sprache, die in verarbeitenden Diensten verwendet wird, definiert den Grad der Komplexität und die Möglichkeiten, die sie bieten.
Normalerweise kombinieren Verarbeitungsdienste zwei oder mehr primitive Operationen aus der Basisschicht, um einen neuen Wert zu erzeugen.

#### 2.2.2.0.0 Funktionen Sprache

Die Sprache der Verarbeitungsdienste ändert sich auf den ersten Blick von primitiven Operationen wie `AddStudent` oder `RemoveStudent` zu `EnsureStudentExists` oder `UpsertStudent`. Sie bieten in der Regel fortgeschrittenere Geschäftslogik-Operationen zur Unterstützung einer höherwertigen Funktionalität.
Hier sind einige Beispiele für die gängigsten Kombinationen, die ein verarbeitender Dienst anbieten kann:

| Verarbeitungsvorgang | Primitive Funktionen |
| ------------------------ | ---------------------------------------------------------- |
| EnsureStudentExistsAsync | RetrieveAllStudents + AddStudentAsync                      |
| UpsertStudentAsync       | RetrieveStudentById + AddStudentAsync + ModifyStudentAsync |
| VerifyStudentExists      | RetrieveAllStudents                                        |
| TryRemoveStudentAsync    | RetrieveStudentById + RemoveStudentByIdAsync               |

Wie Sie sehen können, kann die Kombination von primitiven Funktionen, die Dienste verarbeiten, auch das Hinzufügen einer zusätzlichen Logikebene zu den bestehenden primitiven Operationen beinhalten. Beispielsweise nutzt "VerifyStudentExists" die primitive Funktion "RetrieveAllStudents" und fügt dann eine boolesche Logik hinzu, um zu überprüfen, ob der zurückgegebene Student mit seiner Id aus einer Abfrage tatsächlich existiert oder nicht, bevor er einen "booleschen" Wert zurückgibt.

#### 2.2.2.0.1 Durchreichen

Die verarbeitenden Dienste können einige der Terminologie eines Basis-Dienstes übernehmen. In einem Pass-Through-Szenario kann ein verarbeitender Dienst zum Beispiel so einfach sein wie "Add Student Async". Wir werden die Architekturausgleichsszenarien später in diesem Kapitel besprechen.
Im Gegensatz zu Basis-Diensten müssen Processing-Dienste den Bezeichner "Processing" in ihrem Namen haben, z.B. "StudentProcessingService".

#### 2.2.2.0.2 Sprache auf Klassenebene

Noch wichtiger ist, dass Verarbeitungsdienste den Namen der Entität enthalten müssen, die von ihrem entsprechenden Basis-Dienst unterstützt wird.
Wenn zum Beispiel ein Verarbeitungsdienst von einem "TeacherService" abhängt, muss der Name des Verarbeitungsdienstes "TeacherProcessingService" lauten.

### 2.2.2.1 Abhängigkeiten

Verarbeitungsdienste können nur zwei Arten von Abhängigkeiten haben: einen entsprechenden Basis-Dienst oder einen Utility Broker. Das liegt ganz einfach daran, dass Processing Services nichts anderes als eine zusätzliche übergeordnete Ebene der Geschäftslogik sind, die durch kombinierte primitive Operationen auf der Basis-Ebene orchestriert wird.
Verarbeitungsdienste können auch Utility Broker wie `TimeBroker` oder `LoggingBroker` verwenden, um ihren Berichtsaspekt zu unterstützen, aber sie dürfen niemals mit einem Entity oder Business Broker interagieren.

### 2.2.2.2 One-Basis

Verarbeitungsdienste können nur mit einem einzigen Basis-Dienst interagieren. Ohne einen Basisdienst kann es keine Verarbeitungsschicht geben. Und wie wir bereits über die Sprache und die Namensgebung erwähnt haben, nehmen Verarbeitungsdienste genau denselben Entitätsnamen an wie ihre Basis-Abhängigkeit.
Ein verarbeitender Dienst, der die übergeordnete Geschäftslogik für Studenten handhabt, kommuniziert beispielsweise nur mit seiner Basis-Schicht, die zum Beispiel `StudentService` heißen würde. Das bedeutet, dass verarbeitende Dienste nur einen einzigen Dienst als Abhängigkeit in ihrer Konstruktion oder Initiierung haben, wie folgt:

```csharp
public class StudentProcessingService
{
    private readonly IStudentService studentService;

    public StudentProcessingService(IStudentService studentService) =>
        this.studentService = studentService;
}
```

Verarbeitende Dienste können jedoch Abhängigkeiten von mehreren Utility Brokern wie `DateTimeBroker` oder `LoggingBroker` ... usw. erfordern.

### 2.2.2.3 Nur-Validierungen von verwendeten Daten

Im Gegensatz zu den Diensten der Basis-Schicht validieren die Verarbeitungsdienste nur das, was sie von ihren Eingaben benötigen. Wenn ein verarbeitender Dienst beispielsweise überprüfen muss, ob eine Entität "Student" existiert, und sein Eingabemodell zufällig eine ganze Entität "Student" ist, wird er nur überprüfen, dass die Entität nicht "null" ist und dass die "ID" dieser Entität gültig ist. Der Rest der Entität geht den verarbeitenden Dienst nichts an.
Die verarbeitenden Dienste delegieren die vollständigen Validierungen an die Schicht der Dienste, die sich mit der Basis-Schicht befasst:

```csharp
public ValueTask<Student> UpsertStudentAsync(Student student) =>
TryCatch(async () =>
{
    ValidateStudent(student);

    IQueryable<Student> allStudents =
        this.studentService.RetrieveAllStudents();

    bool isStudentExists = allStudents.Any(abgerufenerStudent =>
        abgerufenStudent.Id == student.Id);

    return isStudentExsits switch {
        false => await this.studentService.RegisterStudentAsync(student),
        _ => await this.studentService.ModifyStudentAsync(student.Id)
    };
});
```

Verarbeitende Dienste sind auch nicht sehr an ausgehenden Validierungen interessiert, außer an denen, die sie innerhalb derselben Routine verwenden werden. Wenn ein verarbeitender Dienst beispielsweise ein Modell abruft und dieses Modell an eine andere Funktion auf primitiver Ebene in der Basis-Schicht weitergibt, muss der verarbeitende Dienst überprüfen, ob das abgerufene Modell gültig ist, je nachdem, welche Attribute des Modells er verwendet.
Bei Pass-Through-Szenarien delegieren die verarbeitenden Dienste die ausgehende Validierung jedoch an die Basis-Schicht.

## 2.2.3 Zuständigkeiten

Die Hauptaufgabe der verarbeitenden Dienste besteht darin, Geschäftslogik höherer Ordnung bereitzustellen. Dies geschieht zusammen mit dem regulären Signatur-Mapping und verschiedenen Use-Only-Validierungen, die wir in diesem Abschnitt im Detail besprechen werden.

### 2.2.3.0 Übergeordnete Logik

Geschäftslogik höherer Ordnung sind Funktionen, die über primitiven Funktionen liegen. Zum Beispiel ist die Funktion "AddStudentAsync" eine primitive Funktion, die nur eine Sache tut. Logik höherer Ordnung ist jedoch, wenn wir versuchen, eine Funktion bereitzustellen, die das Ergebnis einer einzelnen primitiven Funktion wie "VerifyStudentExists" ändert, die einen booleschen Wert anstelle des gesamten Objekts "Student" zurückgibt, oder eine Kombination mehrerer primitiver Funktionen wie "EnsureStudentExistsAsync", die eine Funktion ist, die ein bestimmtes "Student"-Modell nur dann hinzufügt, wenn das oben genannte Objekt noch nicht im Speicher vorhanden ist:

#### 2.2.3.0.0 Shifters

Das Shifter-Muster in einer Geschäftslogik höherer Ordnung liegt vor, wenn das Ergebnis einer bestimmten primitiven Funktion von einem Wert zu einem anderen geändert wird. Idealerweise ist ein primitiver Typ wie `bool` oder `int` kein völlig anderer Typ, da dies das Reinheitsprinzip verletzen würde.
In einem Shifter-Muster wollen wir zum Beispiel überprüfen, ob ein Schüler existiert oder nicht. Wir wollen nicht wirklich das gesamte Objekt, sondern nur, ob es in einem bestimmten System existiert oder nicht. Dies scheint ein Fall zu sein, in dem wir nur mit einem einzigen Basis-Dienst interagieren müssen und den Wert des Ergebnisses auf etwas anderes verschieben. Das sollte perfekt in den Bereich der verarbeitenden Dienste passen. Hier ist ein Beispiel:

```csharp
public ValueTask<bool> VerifyStudentExists(Guid studentId) =>
TryCatch(async () =>
{
    IQueryable<Student> allStudents =
        this.studentService.RetrieveAllStudents();

    ValidateStudents(allStudents);

    return allStudents.Any(student => student.Id == studentId);
});
```

Im obigen Schnipsel haben wir eine Geschäftslogik höherer Ordnung bereitgestellt, indem wir einen booleschen Wert zurückgegeben haben, der angibt, ob ein bestimmter Student mit einer bestimmten `Id` im System existiert oder nicht. Es gibt Fälle, in denen Ihre Orchestrierungsschicht von Diensten sich nicht wirklich mit allen Details einer bestimmten Entität befasst, sondern nur weiß, ob sie als Teil einer übergeordneten Geschäftslogik existiert oder nicht, oder was wir Orchestrierung nennen.

Hier ist ein weiteres beliebtes Beispiel für die Verarbeitung von Diensten, die das Muster verschieben:

```csharp
public int RetrieveStudentsCount() =>
TryCatch(() =>
{
    IQueryable<Student> allStudents =
        this.studentService.RetrieveAllStudents();

    ValidateStudents(allStudents);

    return allStudents.Count();
});
```

Im obigen Beispiel haben wir eine Funktion zum Abrufen der Anzahl aller Studenten in einem bestimmten System bereitgestellt. Es bleibt den Entwicklern des Systems überlassen, ob sie einen "Null"-Wert, der für alle Studenten abgefragt wird, als Ausnahmefall interpretieren, der nicht erwartet wurde, oder ob sie eine "0" zurückgeben; alles hängt davon ab, wie sie das Ergebnis handhaben.
In unserem Fall validieren wir die ausgehenden Daten ebenso wie die eingehenden, insbesondere wenn sie innerhalb der Verarbeitungsfunktion verwendet werden, um sicherzustellen, dass bei vorgelagerten Diensten keine weiteren Ausfälle auftreten.

#### 2.2.3.0.1 Kombinationen

Die Kombination mehrerer primitiver Funktionen aus der Basisschicht zur Erreichung einer übergeordneten Geschäftslogik ist eine der Hauptaufgaben eines verarbeitenden Dienstes. Wie wir bereits erwähnt haben, sind einige der populärsten Beispiele für die Sicherstellung eines bestimmten Studentenmodells wie folgt:

```csharp
public async ValueTask<Student> EnsureStudentExistsAsync(Student student) =>
TryCatch(async () =>
{
    ValidateStudent(student);

    IQueryable<Student> allStudents =
        this.studentService.RetrieveAllStudents();

    Student maybeStudent = allStudents.FirstOrDefault(abgerufenerStudent =>
        abgerufenerStudent.Id == student.Id);

    return maybeStudent switch
    {
        {} => maybeStudent,
        _ => await this.studentService.AddStudentAsync(student)
    };
});
```

Im obigen Codeschnipsel haben wir `RetrieveAll` mit `AddAsync` kombiniert, um eine Geschäftslogikoperation höherer Ordnung zu erreichen. Die Operation `EnsureAsync`, bei der zuerst überprüft werden muss, ob etwas oder eine Entität existiert, bevor versucht wird, es zu persistieren. Die Terminologie rund um diese Geschäftslogikroutinen höherer Ordnung ist sehr wichtig. Ihre Bedeutung liegt hauptsächlich in der Kontrolle der Erwartungen an das Ergebnis und die innere Funktionalität. Sie sorgt aber auch dafür, dass weniger kognitive Ressourcen von den Ingenieuren benötigt werden, um die zugrundeliegenden Fähigkeiten einer bestimmten Routine zu verstehen.
Die konventionelle Sprache, die in all diesen Diensten verwendet wird, stellt auch sicher, dass nicht irrtümlich redundante Fähigkeiten geschaffen werden. So könnte ein Entwicklungsteam ohne jegliche Form von Standard `TryAddStudentAsync` erstellen, während es bereits eine bestehende Funktionalität wie `EnsureStudentExistsAsync` gibt, die genau das Gleiche tut. Die Konvention hier mit der Begrenzung der Größe der Fähigkeiten, die ein bestimmter Dienst haben kann, stellt sicher, dass redundante Arbeit in keinem Fall auftritt.
Es gibt so viele verschiedene Beispiele für Kombinationen, die eine übergeordnete Geschäftslogik erzeugen können, zum Beispiel müssen wir eine Funktionalität implementieren, die sicherstellt, dass ein Student entfernt wird. Wir verwenden `EnsureStudentRemovedByIdAsync`, um ein `RetrieveById` und ein `RemoveById` in derselben Routine zu kombinieren. Es hängt alles davon ab, welche Fähigkeiten ein vorgelagerter Dienst benötigt, um eine solche Funktionalität zu implementieren.

### 2.2.3.1 Abbildung von Unterschriften

Obwohl die verarbeitenden Dienste vollständig auf der Grundlage lokaler Modelle und lokaler Verträge arbeiten, müssen sie dennoch die Modelle der Dienste auf der Basis-Ebene auf ihre eigenen lokalen Modelle abbilden. Wenn beispielsweise ein Basis-Dienst die Ausnahme `StudentValidationException` auslöst, werden die verarbeitenden Dienste diese Ausnahme auf `StudentProcessingDependencyValidationException` abbilden. Lassen Sie uns in diesem Abschnitt über das Mapping sprechen.

#### 2.2.3.1.0 Lokale Modelle ohne Ausnahmen

Im Allgemeinen sind die verarbeitenden Dienste verpflichtet, alle ein- oder ausgehenden Objekte mit einem bestimmten Modell auf das eigene abzubilden. Diese Regel gilt jedoch nicht immer für Nicht-Ausnahme-Modelle. Wenn z.B. ein `StudentProcessingService` auf der Basis eines `Student`-Modells operiert und es keinen Bedarf für ein spezielles Modell für diesen Dienst gibt, dann kann es dem verarbeitenden Dienst erlaubt sein, genau dasselbe Modell aus der Basisschicht zu verwenden.

#### 2.2.3.1.1 Ausnahmemodelle

Wenn es um verarbeitende Dienste geht, die Ausnahmen aus der Basisschicht behandeln, ist es wichtig zu verstehen, dass Ausnahmen in unserem Standard in ihren Namenskonventionen und ihrer Rolle ausdrucksstärker sind als jedes andere Modell. Ausnahmen definieren hier das Was, Wo und Warum jedes einzelnen Mal, wenn sie ausgelöst werden.
Eine Ausnahme mit dem Namen "StudentProcessingServiceException" gibt zum Beispiel die Entität der Ausnahme an, nämlich die Entität "Student". Dann wird der Ort der Ausnahme angegeben, nämlich der `StudentProcessingService`. Und schließlich wird der Grund für diese Ausnahme angegeben, nämlich `ServiceException`, was auf einen internen Fehler des Dienstes hinweist, der nicht auf eine Validierung oder eine Abhängigkeit zurückzuführen ist.
Genau wie die Basis-Schicht, werden die verarbeitenden Dienste die folgende Abbildung auf auftretende Ausnahmen von ihren Abhängigkeiten machen:

| Exception                            | Wrap Inner Exception With | Wrap With                                      | Log Level |
| ------------------------------------ | ------------------------- | ---------------------------------------------- | --------- |
| StudentDependencyValidationException | Any inner exception       | StudentProcessingDependencyValidationException | Error     |
| StudentValidationException           | Any inner exception       | StudentProcessingDependencyValidationException | Error     |
| StudentDependencyException           | -                         | StudentProcessingDependencyException           | Error     |
| StudentServiceException              | \_                        | StudentProcessingDependencyException           | Error     |
| Exception                            | \_                        | StudentProcessingServiceException              | Error     |

[*] [Verarbeitung von Diensten in der Praxis (Teil 1)](https://www.youtube.com/watch?v=VgzoZ-b1A4U)

[*] [Verarbeitung von Diensten in Aktion (Teil 2)](https://www.youtube.com/watch?v=4lfZcWzbIcE)

[*] [Verarbeitung von Diensten in Aktion (Teil 3)](https://www.youtube.com/watch?v=R4sA4V4-_5o)

[*] [Verarbeitung von Diensten in Aktion (Teil 4)](https://www.youtube.com/watch?v=u4uqBiB1TaI)
